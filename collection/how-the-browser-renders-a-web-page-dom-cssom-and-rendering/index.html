<!doctype html>
<html data-n-head-ssr>
  <head>
    <title>MixinHub</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="description" name="description" content=""><base href="/mixin-hub/"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.png"><link data-n-head="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat"><link rel="preload" href="/mixin-hub/_nuxt/dea7c48.js" as="script"><link rel="preload" href="/mixin-hub/_nuxt/3acc980.js" as="script"><link rel="preload" href="/mixin-hub/_nuxt/ffbb57e.js" as="script"><link rel="preload" href="/mixin-hub/_nuxt/c4e6356.js" as="script"><link rel="preload" href="/mixin-hub/_nuxt/9955695.js" as="script"><style data-vue-ssr-id="517a8dd7:0 fa7ff0ca:0 5c346d62:0 0bc462b6:0 384e9717:0 3c9af68d:0">code[class*=language-],pre[class*=language-]{color:#000;background:0 0;text-shadow:0 1px #fff;font-family:Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:#b3d4fc}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#9a6e3a;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#000;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}:root{--color-primary:#305d83;--color-primary-lighter:#5a98d0;--color-accent:orange;--color-white:#fff;--color-text:#080610;--color-gray-dark:#999;--header-height:72px;--header-height-mobile:54px;--breakpoint-sm:600px;--breakpoint-md:768px;--breakpoint-lg:1024px;--font-title-1:4.8rem;--font-title-2:2.4rem;--font-title-3:2rem;--font-title-4:1.8rem;--font-text:1.6rem;--font-text-small:1.4rem;--font-caption:1.2rem}html{font-size:10px;overflow-x:hidden;width:100%}body{font-family:Montserrat,Roboto,Segoe UI,Helvetica Neue,sans-serif;font-weight:400;line-height:1.42857rem;text-transform:none;letter-spacing:normal}body *{font-size:1.6rem;font-size:var(--font-text);line-height:1}a,button,h1,h2,h3,h4,h5,p{font-family:Montserrat,Roboto,Segoe UI,Helvetica Neue,sans-serif}p{line-height:1.5}*,:after,:before{box-sizing:border-box;margin:0}.container{max-width:1024px;margin-left:auto;margin-right:auto}.image{display:block;position:relative}.image img{position:absolute;display:block;width:100%;height:100%;bottom:0;left:0;right:0;top:0}.image.is-4by3{padding-top:75%}.image.is-3by1{padding-top:33.3333%}.image.is-square{padding-top:100%}.container-main-content{min-height:calc(100vh - 158px)}.container.container-article{max-width:1024px!important;padding:16px 0}.container.container-article h1{font-size:3.5rem;line-height:60px;font-family:ui-monospace}.nuxt-content h2{font-weight:700;font-size:28px}.nuxt-content h3{font-weight:700;font-size:22px}.nuxt-content p{margin-bottom:20px}[data-v-62d82ce3]:root{--color-primary:#305d83;--color-primary-lighter:#5a98d0;--color-accent:orange;--color-white:#fff;--color-text:#080610;--color-gray-dark:#999;--header-height:72px;--header-height-mobile:54px;--breakpoint-sm:600px;--breakpoint-md:768px;--breakpoint-lg:1024px;--font-title-1:4.8rem;--font-title-2:2.4rem;--font-title-3:2rem;--font-title-4:1.8rem;--font-text:1.6rem;--font-text-small:1.4rem;--font-caption:1.2rem}html[data-v-62d82ce3]{font-size:10px;overflow-x:hidden;width:100%}body[data-v-62d82ce3]{font-family:Montserrat,Roboto,Segoe UI,Helvetica Neue,sans-serif;font-weight:400;line-height:1.42857rem;text-transform:none;letter-spacing:normal}body [data-v-62d82ce3]{font-size:1.6rem;font-size:var(--font-text);line-height:1}a[data-v-62d82ce3],button[data-v-62d82ce3],h1[data-v-62d82ce3],h2[data-v-62d82ce3],h3[data-v-62d82ce3],h4[data-v-62d82ce3],h5[data-v-62d82ce3],p[data-v-62d82ce3]{font-family:Montserrat,Roboto,Segoe UI,Helvetica Neue,sans-serif}p[data-v-62d82ce3]{line-height:1.5}[data-v-62d82ce3],[data-v-62d82ce3]:after,[data-v-62d82ce3]:before{box-sizing:border-box;margin:0}.container[data-v-62d82ce3]{max-width:1024px;margin-left:auto;margin-right:auto}.image[data-v-62d82ce3]{display:block;position:relative}.image img[data-v-62d82ce3]{position:absolute;display:block;width:100%;height:100%;bottom:0;left:0;right:0;top:0}.image.is-4by3[data-v-62d82ce3]{padding-top:75%}.image.is-3by1[data-v-62d82ce3]{padding-top:33.3333%}.image.is-square[data-v-62d82ce3]{padding-top:100%}.navbar[data-v-62d82ce3]{position:-webkit-sticky;position:sticky;top:0;background:#fff;z-index:9;padding:0 48px;height:72px;height:var(--header-height);display:flex;justify-content:space-between;align-items:center;box-shadow:0 5px 3px 1px #fff}@media(max-width:1024px){.navbar[data-v-62d82ce3]{padding:0 12px;height:54px;height:var(--header-height-mobile)}}.navbar-logo img[data-v-62d82ce3]{max-height:72px;max-height:var(--header-height)}@media(max-width:1024px){.navbar-logo img[data-v-62d82ce3]{max-height:50px}}.navbar-menu[data-v-62d82ce3]{position:relative}.navbar-item[data-v-62d82ce3]{font-weight:600;padding:8px}.navbar-end[data-v-62d82ce3]{display:flex}@media(max-width:1024px){.navbar-end[data-v-62d82ce3]{display:none}}.navbar-end-mobile[data-v-62d82ce3]{flex-direction:column;position:absolute;right:0;background:#fff;min-width:150px;border:1px solid #ddd;border-radius:4px}.navbar-item-link[data-v-62d82ce3]{text-transform:uppercase;font-weight:700;color:#305d83;color:var(--color-primary);transition:all .3s ease-in-out;text-decoration:none}.navbar-item-link[data-v-62d82ce3]:hover{opacity:.8}[data-v-b328e8fe]:root{--color-primary:#305d83;--color-primary-lighter:#5a98d0;--color-accent:orange;--color-white:#fff;--color-text:#080610;--color-gray-dark:#999;--header-height:72px;--header-height-mobile:54px;--breakpoint-sm:600px;--breakpoint-md:768px;--breakpoint-lg:1024px;--font-title-1:4.8rem;--font-title-2:2.4rem;--font-title-3:2rem;--font-title-4:1.8rem;--font-text:1.6rem;--font-text-small:1.4rem;--font-caption:1.2rem}html[data-v-b328e8fe]{font-size:10px;overflow-x:hidden;width:100%}body[data-v-b328e8fe]{font-family:Montserrat,Roboto,Segoe UI,Helvetica Neue,sans-serif;font-weight:400;line-height:1.42857rem;text-transform:none;letter-spacing:normal}body [data-v-b328e8fe]{font-size:1.6rem;font-size:var(--font-text);line-height:1}a[data-v-b328e8fe],button[data-v-b328e8fe],h1[data-v-b328e8fe],h2[data-v-b328e8fe],h3[data-v-b328e8fe],h4[data-v-b328e8fe],h5[data-v-b328e8fe],p[data-v-b328e8fe]{font-family:Montserrat,Roboto,Segoe UI,Helvetica Neue,sans-serif}p[data-v-b328e8fe]{line-height:1.5}[data-v-b328e8fe],[data-v-b328e8fe]:after,[data-v-b328e8fe]:before{box-sizing:border-box;margin:0}.container[data-v-b328e8fe]{max-width:1024px;margin-left:auto;margin-right:auto}.image[data-v-b328e8fe]{display:block;position:relative}.image img[data-v-b328e8fe]{position:absolute;display:block;width:100%;height:100%;bottom:0;left:0;right:0;top:0}.image.is-4by3[data-v-b328e8fe]{padding-top:75%}.image.is-3by1[data-v-b328e8fe]{padding-top:33.3333%}.image.is-square[data-v-b328e8fe]{padding-top:100%}.navbar-burger[data-v-b328e8fe]{color:#4a4a4a;cursor:pointer;display:block;height:3.25rem;position:relative;width:3.25rem;margin-left:auto;display:none}@media(max-width:1024px){.navbar-burger[data-v-b328e8fe]{display:block}}.navbar-burger span[data-v-b328e8fe]{background-color:currentColor;display:block;height:1px;left:calc(50% - 8px);position:absolute;transform-origin:center;transition-duration:86ms;transition-property:background-color,opacity,transform;transition-timing-function:ease-out;width:16px}.navbar-burger span[data-v-b328e8fe]:first-child{top:calc(50% - 6px)}.navbar-burger span[data-v-b328e8fe]:nth-child(2){top:calc(50% - 1px)}.navbar-burger span[data-v-b328e8fe]:nth-child(3){top:calc(50% + 4px)}.navbar-burger[data-v-b328e8fe]:hover{background-color:rgba(0,0,0,.05)}.navbar-burger.is-active span[data-v-b328e8fe]:first-child{transform:translateY(5px) rotate(45deg)}.navbar-burger.is-active span[data-v-b328e8fe]:nth-child(2){opacity:0}.navbar-burger.is-active span[data-v-b328e8fe]:nth-child(3){transform:translateY(-5px) rotate(-45deg)}[data-v-5678ae99]:root{--color-primary:#305d83;--color-primary-lighter:#5a98d0;--color-accent:orange;--color-white:#fff;--color-text:#080610;--color-gray-dark:#999;--header-height:72px;--header-height-mobile:54px;--breakpoint-sm:600px;--breakpoint-md:768px;--breakpoint-lg:1024px;--font-title-1:4.8rem;--font-title-2:2.4rem;--font-title-3:2rem;--font-title-4:1.8rem;--font-text:1.6rem;--font-text-small:1.4rem;--font-caption:1.2rem}html[data-v-5678ae99]{font-size:10px;overflow-x:hidden;width:100%}body[data-v-5678ae99]{font-family:Montserrat,Roboto,Segoe UI,Helvetica Neue,sans-serif;font-weight:400;line-height:1.42857rem;text-transform:none;letter-spacing:normal}body [data-v-5678ae99]{font-size:1.6rem;font-size:var(--font-text);line-height:1}a[data-v-5678ae99],button[data-v-5678ae99],h1[data-v-5678ae99],h2[data-v-5678ae99],h3[data-v-5678ae99],h4[data-v-5678ae99],h5[data-v-5678ae99],p[data-v-5678ae99]{font-family:Montserrat,Roboto,Segoe UI,Helvetica Neue,sans-serif}p[data-v-5678ae99]{line-height:1.5}[data-v-5678ae99],[data-v-5678ae99]:after,[data-v-5678ae99]:before{box-sizing:border-box;margin:0}.container[data-v-5678ae99]{max-width:1024px;margin-left:auto;margin-right:auto}.image[data-v-5678ae99]{display:block;position:relative}.image img[data-v-5678ae99]{position:absolute;display:block;width:100%;height:100%;bottom:0;left:0;right:0;top:0}.image.is-4by3[data-v-5678ae99]{padding-top:75%}.image.is-3by1[data-v-5678ae99]{padding-top:33.3333%}.image.is-square[data-v-5678ae99]{padding-top:100%}.footer[data-v-5678ae99]{display:flex;justify-content:space-between;align-items:center;padding:25px 50px;background:#5a98d0;background:var(--color-primary-lighter);color:#fff;color:var(--color-white);border-top-right-radius:100px}@media(max-width:768px){.footer[data-v-5678ae99]{flex-direction:column;align-items:flex-start}}.links[data-v-5678ae99]{display:flex;align-items:center}.link[data-v-5678ae99]{padding:0 8px}</style><link rel="preload" href="/mixin-hub/_nuxt/static/1632317493/collection/how-the-browser-renders-a-web-page-dom-cssom-and-rendering/state.js" as="script"><link rel="preload" href="/mixin-hub/_nuxt/static/1632317493/collection/how-the-browser-renders-a-web-page-dom-cssom-and-rendering/payload.js" as="script"><link rel="preload" href="/mixin-hub/_nuxt/static/1632317493/manifest.js" as="script">
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div><nav role="navigation" aria-label="main navigation" class="navbar" data-v-62d82ce3><div class="navbar-brand" data-v-62d82ce3><a href="/mixin-hub/" class="navbar-logo nuxt-link-active" data-v-62d82ce3><img src="/mixin-hub/_nuxt/img/logo-text.8462407.png" height="40" alt="Mixin-hub Logo" data-v-62d82ce3></a></div> <div class="navbar-menu" data-v-62d82ce3><a role="button" aria-label="menu" aria-expanded="false" class="navbar-burger" data-v-b328e8fe data-v-62d82ce3><span aria-hidden="true" data-v-b328e8fe></span> <span aria-hidden="true" data-v-b328e8fe></span> <span aria-hidden="true" data-v-b328e8fe></span></a> <!----> <div class="navbar-end" data-v-62d82ce3><div class="navbar-item" data-v-62d82ce3><a href="/mixin-hub/learning365" class="navbar-item-link" data-v-62d82ce3>365 Learning</a></div> <div class="navbar-item" data-v-62d82ce3><a href="/mixin-hub/collection" class="navbar-item-link nuxt-link-active" data-v-62d82ce3>Collection</a></div> <div class="navbar-item" data-v-62d82ce3><a href="/mixin-hub/blog" class="navbar-item-link" data-v-62d82ce3>Blog</a></div> <div class="navbar-item" data-v-62d82ce3><a href="/mixin-hub/about" class="navbar-item-link" data-v-62d82ce3>About</a></div></div></div></nav> <div class="container container-article container-main-content"><h1>How the browser renders a web page? — DOM, CSSOM, and Rendering</h1> <p class="my-5"><i>Source:</i> <a href="https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969" target="_blank" rel="noopener noreferrer">https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969</a></p> <div class="nuxt-content"><p>Whenever you are developing a website, there are certain things that are very essential for a good user experience. Some of the common problems a website may encounter could be slow loading of the resources, waiting for unnecessary files to download on initial render, a flash of unstyled content (FOUC), etc. To avoid such problems, we need to understand the lifecycle of how a browser renders a typical webpage.</p>
<p>First, we need to understand what DOM is. When a browser sends a request to a server to fetch an HTML document, the server returns an HTML page in binary stream format which is basically a text file with the response header Content-Type set to the value text/html; charset=UTF-8.</p>
<p>Here text/html is a MIME Type which tells the browser that it is an HTML document and charset=UTF-8 tells the browser that it is encoded in UTF-8 character encoding. Using this information, the browser can convert the binary format into a readable text file. This has shown below in the screenshot.</p>
<p><img alt="" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/19635c9a-eede-4be2-a81c-7a64c6cfb5a7/1_Tm-HPhmGA0BL7HIj38H8Qw.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210125T151038Z&X-Amz-Expires=86400&X-Amz-Signature=f47526ca66a355798c6ae5ea958d7c04c855d2925b443eeca60cfa8732a73179&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%221_Tm-HPhmGA0BL7HIj38H8Qw.png%22"></p>
<p>If this header is missing, the browser would not understand how to process the file and it will render in plain text format. But if everything is OK, after this conversion, the browser can start reading the HTML document. A typical HTML document could look like this.</p>
<div class="nuxt-content-highlight"><pre class="line-numbers language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">HTML</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Rendering Test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
      
        <span class="token comment">&lt;!-- stylesheet --></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./style.css<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Hello World!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>This is a sample paragraph.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
      
        <span class="token comment">&lt;!-- script --></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./main.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>
</code></pre></div>
<p>In the above document, our webpage is dependent on style.css to provide styles to HTML elements and main.js to perform some JavaScript operations. With some neat CSS styles, our above webpage will look like this.</p>
<p><img alt="" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/7a15ce6e-a83e-49ec-97f3-7ec955a0852c/1_3bFOsAXQPJtczaQcQcVZ1A.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210125T151152Z&X-Amz-Expires=86400&X-Amz-Signature=da8f973725949ba7d4edeb2894a73866915333426eaf69bf20277a8340e0f7cd&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%221_3bFOsAXQPJtczaQcQcVZ1A.png%22"></p>
<p>But the question still stands, how does a browser render this beautiful-looking webpage from a simple HTML file which contains nothing but text? For that, we need to understand what is DOM, CSSOM, and Render Tree?</p>
<h3 id="document-object-model-dom"><a href="#document-object-model-dom" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>Document Object Model (DOM)</h3>
<p>When the browser reads HTML code, whenever it encounters an HTML element like <code>html</code>, <code>body</code>, <code>div</code> etc., it creates a JavaScript object called a <strong><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node" rel="nofollow noopener noreferrer" target="_blank">Node</a></strong>. Eventually, all HTML elements will be converted to JavaScript objects.</p>
<p>Since every HTML element has different properties, the Node object will be created from different classes (<em>constructor functions</em>). For example, the Node object for the <code>div</code> element is created from <code>[HTMLDivElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)</code> which <strong>inherits</strong> <code>[Node](https://developer.mozilla.org/en-US/docs/Web/API/Node)</code> class. For our earlier HTML document, we can visualize these nodes using a simple test as below.</p>
<p><img alt="" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2ded69d2-bd4e-4548-8d9f-ca3d7360f03b/1_DmxJT96ZM3ob8TsgCFUJzw.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210125T151225Z&X-Amz-Expires=86400&X-Amz-Signature=882abd1773590dc6f3f3b5630b1e93e97701314cb1caa530cc5dd7bf2b4e99e7&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%221_DmxJT96ZM3ob8TsgCFUJzw.png%22"></p>
<p>The browser comes with built-in classes like <code>[HTMLDivElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement)</code>, <code>[HTMLScriptElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement)</code>, <code>[Node](https://developer.mozilla.org/en-US/docs/Web/API/Node)</code> etc.</p>
<p>After the browser has created Nodes from the HTML document, it has to create a <strong>tree-like structure</strong> of these node objects. Since our HTML elements in the HTML file are nested inside each other, the browser needs to replicate that but using Node objects it has previously created. This will help the browser efficiently render and manage the webpage throughout its lifecycle.</p>
<p><img alt="" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/fa30718b-f4e6-4863-aedb-50c789ea9aa0/1_YSA8lCfCVPn3d6GWAVokrA.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210125T151254Z&X-Amz-Expires=86400&X-Amz-Signature=888fb488d33d1327b25177a2bf7f1964e330e77c5ac0b3aebc14af9d4e766420&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%221_YSA8lCfCVPn3d6GWAVokrA.png%22"></p>
<p>A DOM tree for our earlier HTML document looks like above. A DOM tree starts from the topmost element which is html element and branches out as per the occurrence and nesting of HTML elements in the document. Whenever an HTML element is found, it creates a DOM node (Node) object from its respective class (constructor function).</p>
<blockquote>
<p>💡 A DOM node doesn’t always have to be an HTML element. When the browser creates a DOM tree, it also saves things like comments, attributes, text as separate nodes in the tree. But for the simplicity, we will just consider DOM nodes for HTML elements AKA DOM element. Here is the list of all DOM node types.</p>
</blockquote>
<p>You can visualize the DOM tree in Google Chrome DevTools Console as shown below. This will show you the hierarchy of DOM elements (a high-level view of DOM tree) with properties of each DOM element.</p>
<p><img alt="" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/b4ad7149-1c5d-4f4b-83dd-a569cd92f281/1_Uo2wfq060OMSLyTTCm2zFw.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210125T151317Z&X-Amz-Expires=86400&X-Amz-Signature=eb5b2e1b375f88e236cff36893c47ddd87ff9a4649d35083081736bd24fae29c&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%221_Uo2wfq060OMSLyTTCm2zFw.png%22"></p>
<p>JavaScript doesn’t understand what DOM is, it is not part of the JavaScript specifications. DOM is a high-level Web API provided by the browser to efficiently render a webpage and expose it publically for the developer to dynamically manipulate DOM elements for various purposes.</p>
<blockquote>
<p>💡 Using DOM API, developers can add or remove HTML elements, change its appearance or bind event listeners. Using DOM API, HTML elements can be created or cloned in memory and maniuplated without affecting the rendered DOM tree. This gives developers the ability to construct highly dynamic web page with rich user experience.</p>
</blockquote>
<h3 id="css-object-model-cssom"><a href="#css-object-model-cssom" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>CSS Object Model (CSSOM)</h3>
<p>When we design a website, our intentions are to make it as good looking as possible. And we do that by providing some styles to HTML elements. In the HTML page, we provide styles to HTML elements using CSS which stands for Cascading Style Sheets. Using CSS selectors, we can target DOM elements and set a value to style property such as color or font-size.</p>
<p>There are different methods of applying styles to HTML elements like using an external CSS file, with embedded CSS using </p><style></style>
<p></p><p>Let’s say, for our earlier example, we are going to use the below CSS styles (this is not the CSS used for the card shown in the screenshot). For the sake of simplicity, we are not going to be bothered about how we are importing the CSS styles in the HTML page.</p>
<div class="nuxt-content-highlight"><pre class="line-numbers language-css"><code><span class="token selector">html</span> <span class="token punctuation">{</span>
    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">body</span> <span class="token punctuation">{</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">14</span><span class="token unit">px</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector"><span class="token class">.container</span></span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span><span class="token unit">px</span><span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span><span class="token unit">px</span><span class="token punctuation">;</span>
    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token color">black</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector"><span class="token class">.container</span> <span class="token combinator">></span> h1</span> <span class="token punctuation">{</span>
    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token color">gray</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector"><span class="token class">.container</span> <span class="token combinator">></span> p</span> <span class="token punctuation">{</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">12</span><span class="token unit">px</span><span class="token punctuation">;</span>
    <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>After constructing the DOM, the browser reads CSS from all the sources (<em>external, embedded, inline, user-agent, etc.</em>) and construct a <strong><a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model" rel="nofollow noopener noreferrer" target="_blank">CSSOM</a></strong>. CSSOM stands for <strong>CSS Object Model</strong> which is a Tree Like structure just like DOM.</p>
<p>Each node in this tree contains CSS style information that will be applied to DOM elements that it target (<em>specified by the selector</em>). CSSOM, however, does not contain DOM elements which can’t be printed on the screen like <code>&lt;meta></code>, <code>&lt;script></code>, <code>&lt;title></code> etc.</p>
<p>As we know, most of the browser comes with its own stylesheet which is called as <strong><a href="https://stackoverflow.com/questions/12582624/what-is-a-user-agent-stylesheet" rel="nofollow noopener noreferrer" target="_blank">user agent stylesheet</a></strong>, the browser first computes final CSS properties for DOM element by overriding user agent styles with CSS provided by the developer properties (<em><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity" rel="nofollow noopener noreferrer" target="_blank">using specificity rules</a></em>) and then construct a node.</p>
<p>Even if a CSS property (<em>such as <code>[display](https://developer.mozilla.org/en-US/docs/Web/CSS/display)</code></em>) for a particular HTML element isn’t defined by either the developer or the browser, its value is set to the <strong>default value</strong> of that property as specified by the <strong><a href="https://www.w3.org/Style/CSS/" rel="nofollow noopener noreferrer" target="_blank">W3C CSS</a></strong> standard. While selecting the default value of a CSS property, some rules of <strong>inheritance</strong> are used if a property qualifies for the inheritance as mentioned in the <strong><a href="https://www.w3.org/TR/CSS1/#inheritance" rel="nofollow noopener noreferrer" target="_blank">W3C documentation</a></strong>.</p>
<p>For example, <code>color</code> and <code>font-size</code> among others inherits the value of the parent if these properties are missing for an HTML element. So you can imagine having these properties on an HTML element and all its children inheriting it. This is called <strong>cascading of styles</strong> and that’s why CSS is an acronym of <strong>Cascading Style Sheets</strong>. This is the very reason why the browser constructs a CSSOM, a tree-like structure to <strong>compute styles</strong> based on CSS cascading rules.</p>
<blockquote>
<p>💡 You can see the computed style of an HTML element by using Chrome DevTools console in Elements panel. Select any HTML element from the left panel and click on the computed tab on the right panel.</p>
</blockquote>
<p>We can visualize the CSSOM tree for our earlier example using the below diagram. For the sake of simplicity, we are going to ignore the user-agent styles and focus on CSS styles mentioned earlier.</p>
<p><img alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b808a782-7bec-4f87-a5e7-1b2007061a03/1_DJg1yRx-AzkZposWbJKcaA.png" src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b808a782-7bec-4f87-a5e7-1b2007061a03/1_DJg1yRx-AzkZposWbJKcaA.png"></p>
<p>As you can see from the above diagram, our CSSOM tree does not contain elements which do not get printed on the screen like <link>, </p><title>,  etc. CSS property values in the red colors are cascaded down from the top while property values in the gray are overriding the inherited values.</title>
<p></p><h3 id="render-tree"><a href="#render-tree" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>Render Tree</h3>
<p>Render-Tree is also a tree-like structure constructed by combining DOM and CSSOM trees together. The browser has to calculate the <strong>layout</strong> of each visible element and <strong>paint</strong> them on the screen, for that browser uses this Render-Tree. Hence, unless Render-Tree isn’t constructed, nothing is going to get printed on the screen which is why we need both DOM and CSSOM trees.</p>
<p>As Render-Tree is a low-level representation of what will eventually get printed on the screen, it won’t contain nodes that do not hold any area in the pixel matrix. For example, <code>display:none;</code> elements have dimensions of <code>0px X 0px</code>, hence they won’t be present in Render-Tree.</p>
<p><img alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f4e7b5a2-aba0-4267-b779-058b98328fc8/1_8HnhiojSoPaJAWkruPhDwA.png" src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f4e7b5a2-aba0-4267-b779-058b98328fc8/1_8HnhiojSoPaJAWkruPhDwA.png"></p>
<p>As you can see from the above diagram, Render-Tree combines DOM and CSSOM to generate a tree-like structure containing only the elements which will be printed on the screen.</p>
<p>Since in CSSOM, <code>p</code> element situated inside <code>div</code> has <code>display:none;</code> style set on it, it and its children won’t be present in Render-Tree, since it occupies no space on the screen. However, if you have elements with <code>visibility:hidden</code> or <code>opacity:0</code>, they will occupy space on the screen hence they will be present in the Render-Tree.</p>
<p>Unlike DOM API which gives access to the DOM elements in the DOM tree constructed by the browser, CSSOM is kept hidden from the user. But since the browser combines DOM and CSSOM to form the Render Tree, the browser exposes the CSSOM node of a DOM element by providing high-level API on the DOM element itself. This enables the developer to access or change the CSS properties of a CSSOM node.</p>
<blockquote>
<p>💡 Since manipulating styles of an element using JavaScript is beyond the scope of this article, so here is the link to awesome CSS Tricks Article that covers the broad spectrum of CSSOM API. We also have new CSS Typed Object API in JavaScript which is more accurate way to maniulate styles of an element.</p>
</blockquote>
<h2 id="rendering-sequence"><a href="#rendering-sequence" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>Rendering Sequence</h2>
<p>Now that we have a good understanding of what DOM, CSSOM, and Render-Tree are, let’s understand how a browse renders a typical webpage using them. Having a minimal understanding of this process is crucial for any web developers as it will help us design our website for maximum user experience (UX) and performance.</p>
<p>When a web page is loaded, the browser first reads the HTML text and constructs DOM Tree from it. Then it processes the CSS whether that is inline, embedded, or external CSS and constructs the CSSOM Tree from it.</p>
<p>After these trees are constructed, then it constructs the Render-Tree from it. Once the Render-Tree is constructed, then the browser starts the printing individual elements on the screen.</p>
<h3 id="layout-operation"><a href="#layout-operation" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>Layout operation</h3>
<p>The first browser creates the layout of each individual Render-Tree node. The layout consists of the <strong>size of each node</strong> in pixels and where (<em>position</em>) it will be printed on the screen. This process is called <strong>layout</strong> since the browser is calculating the layout information of each node.</p>
<p>This process is also called <strong>reflow</strong> or <strong>browser reflow</strong> and it can also occur when you <strong>scroll</strong>, <strong>resize</strong> the window or <strong>manipulate DOM</strong> elements. Here is a <strong><a href="https://stackoverflow.com/a/27637245/2790983" rel="nofollow noopener noreferrer" target="_blank">list</a></strong> of events that can trigger the <strong>layout/reflow</strong> of the elements.</p>
<blockquote>
<p>💡 We should avoid the webpage going through multiple layout operations for minuscule reasons since it is a costly operation. Here is an article by Paul Lewis where he talks about how we can avoid complex and costly layout operations as well as layout thrashing.</p>
</blockquote>
<h3 id="paint-operation"><a href="#paint-operation" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>Paint operation</h3>
<p>Until now we have a list of geometries that need to be printed on the screen. Since <strong>elements</strong> (<em>or a sub-tree</em>) in the Render-Tree can overlap each other and they can have CSS properties that make them frequently change the look, position, or geometry (<em>such as animations</em>), the browser creates a <strong>layer</strong> for it.</p>
<p>Creating layers helps the browser efficiently perform painting operations throughout the lifecycle of a web page such as while scrolling or resizing the browser window. Having layers also help the browser correctly draw elements in the stacking order (<em>along the z-axis</em>) as they were intended by the developer.</p>
<p>Now that we have layers, we can combine them and <strong>draw</strong> them on the screen. But the browser does not draw all the layers in a single go. Each layer is drawn separately first.</p>
<p>Inside each layer, the browser fills the individual pixels for whatever visible property the element has such as border, background color, shadow, text, etc. This process is also called as <strong>rasterization</strong>. To increase performance, the browser may use different <strong>threads</strong> to perform rasterization.</p>
<p>The analogy of layers in <strong>Photoshop</strong> can be applied to how the browser renders a web page as well. You can visualize different layers on a web page from Chrome DevTools. Open DevTools and from <strong>more tools</strong> options, select <strong>Layers</strong>. You can also visualize layer borders from the <strong>Rendering</strong> panel.</p>
<blockquote>
<p>💡 Rasterization is normally done in CPU which makes it slow and expensive, but we now have new techniques to do it in GPU for performance enhancement. This intel article covers painting topic in details, it’s a must read. To understand concept of layers in great details, this is a must read article.</p>
</blockquote>
<h2 id="compositing-operation"><a href="#compositing-operation" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a><strong>Compositing operation</strong></h2>
<p>Until now, we haven’t drawn a single pixel on the screen. What we have are different layers (<em>bitmap images</em>) that should be drawn on the screen in a specific order. In <strong>compositing</strong> operations, these layers are sent to GPU to finally draw it on the screen.</p>
<p>Sending entire layers to draw is clearly inefficient because this has to happen every time there is a <strong>reflow</strong> (<em>layout</em>) or <strong><a href="https://stackoverflow.com/questions/2549296/whats-the-difference-between-reflow-and-repaint" rel="nofollow noopener noreferrer" target="_blank">repaint</a></strong>. Hence, a layer is broken down into different <strong>tiles</strong> which then will be drawn on the screen. You can also visualize these tiles in Chrome’s DevTool Rendering panel.</p>
<p>From the above information, we can construct a sequence of events the browser goes through from a web page to render things on the screen from as simple as HTML and CSS text content.</p>
<p><img alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a1293706-01c0-4984-8240-130b65c746fd/1_yQJkz12sPxS-kJoMDqzbEQ.png" src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a1293706-01c0-4984-8240-130b65c746fd/1_yQJkz12sPxS-kJoMDqzbEQ.png"></p>
<p>This sequence of events is also called the <strong><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path" rel="nofollow noopener noreferrer" target="_blank">critical rendering path</a></strong>.</p>
<blockquote>
<p>💡 Mariko Kosaka has written a beautiful article on this process with cool illustrations and broader explanations of each concept. Highly recommended.</p>
</blockquote>
<h2 id="browser-engines"><a href="#browser-engines" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a><strong>Browser engines</strong></h2>
<p>The job of creating DOM Tree, CSSOM Tree, and handle rendering logic is done using a piece of software called a <strong><a href="https://en.wikipedia.org/wiki/Browser_engine" rel="nofollow noopener noreferrer" target="_blank">Browser Engine</a></strong> (<em>also known as <strong>Rendering Engine</strong> or <strong>Layout Engine</strong></em>) which resides inside the browser. This browser engine contains all the necessary elements and logic to render a web page from HTML code to actual pixels on the screen.</p>
<p>If you heard people talking about <strong><a href="https://en.wikipedia.org/wiki/WebKit" rel="nofollow noopener noreferrer" target="_blank">WebKit</a></strong>, they were talking about a browser engine. <strong>WebKit</strong> is used by Apple’s Safari browser and was the default rendering engine for the Google Chrome browser. As of now, the <strong><a href="https://en.wikipedia.org/wiki/Chromium_(web_browser)" rel="nofollow noopener noreferrer" target="_blank">Chromium</a></strong> project uses <strong><a href="https://en.wikipedia.org/wiki/Blink_(browser_engine)" rel="nofollow noopener noreferrer" target="_blank">Blink</a></strong> as the default rendering engine. <strong><a href="https://stackoverflow.com/a/3468311/2790983" rel="nofollow noopener noreferrer" target="_blank">Here is a list</a></strong> of different browser engine used by some of the top web browsers.</p>
<h2 id="rendering-process-in-browsers"><a href="#rendering-process-in-browsers" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a>Rendering Process in browsers</h2>
<p>We all know that JavaScript language is standardized through the <strong><a href="https://en.wikipedia.org/wiki/ECMAScript" rel="nofollow noopener noreferrer" target="_blank">ECMAScript</a></strong> standard, in fact since <a href="https://dev.to/theoutlander/oracle-owns-the-trademark-to-javascript-1fil" rel="nofollow noopener noreferrer" target="_blank">JavaScript is a registered trademark</a>, we just call it ECMAScript now. Therefore, every JavaScript engine provider such as <strong><a href="http://v8.dev/" rel="nofollow noopener noreferrer" target="_blank">V8</a></strong>, <strong><a href="https://en.wikipedia.org/wiki/Chakra_(JavaScript_engine)" rel="nofollow noopener noreferrer" target="_blank">Chakra</a></strong>, <strong><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" rel="nofollow noopener noreferrer" target="_blank">Spider Monkey</a></strong>, etc. has to obey the rules of this standard.</p>
<p>Having a standard gives us consistent JavaScript experience among all JavaScript runtimes such as browsers, Node, Deno, etc. This is great for the consistent and flawless development of JavaScript (<em>and web</em>) applications for multiple platforms.</p>
<p>However, that’s not the case with how a browser renders things. HTML, CSS, or JavaScript, these languages are standardized by some entity or some organization. However, how a browser manages them together to render things on the screen is not standardized. The browser engine of Google Chrome might do things differently than the browser engine of Safari.</p>
<p>Therefore, it’s hard to predict the rendering sequence in a particular browser and the mechanism behind it. However, the <a href="https://html.spec.whatwg.org/" rel="nofollow noopener noreferrer" target="_blank">HTML5 specification</a> has made some effort to standardize how <strong><a href="https://html.spec.whatwg.org/multipage/rendering.html" rel="nofollow noopener noreferrer" target="_blank">rendering</a></strong> should work in theory but how browsers adhere to this standard is totally up to them.</p>
<p>Despite these inconsistencies, there are some common principles that are usually the same among all browsers. Let’s understand the common approach a browser takes to render things on the screen and the lifecycle events of this process. To understand this process, I have prepared a <strong><a href="https://github.com/course-one/browser-rendering-test" rel="nofollow noopener noreferrer" target="_blank">small project</a></strong> to test different rendering scenarios (<em>link below</em>).</p>
<h3 id="parsing-and-external-resources"><a href="#parsing-and-external-resources" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a><strong>Parsing and External Resources</strong></h3>
<p><strong>Parsing</strong> is the process of reading HTML content and constructing a DOM tree from it. Hence the process is also called <strong>DOM parsing</strong> and the program that does that is called the <strong>DOM parser</strong>.</p>
<p>Most browsers provide the <code>[DOMParser](https://developer.mozilla.org/en-US/docs/Web/API/DOMParser)</code> Web API to construct a DOM tree from the HTML code. An instance of <code>DOMParser</code> class represents a DOM parser and using the <code>parseFromString</code> prototype method, we can parse raw HTML text (<em>code</em>) into a DOM tree (<em>as shown below</em>).</p>
<p><img alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8632d843-373f-470a-8d8a-461e7a2efadb/1_DTO0PBRawrEdZakWloQVjg.png" src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8632d843-373f-470a-8d8a-461e7a2efadb/1_DTO0PBRawrEdZakWloQVjg.png"></p>
<p>When the browser request for a webpage and server responds with some HTML text (with Content-Type header set to text/html), a browser may start parsing the HTML as soon as a few characters or lines of the entire document are available. Hence the browser can build the DOM tree incrementally, one node at a time. The browser parses HTML from top to bottom and not anywhere in the middle since the HTML represents a nested tree-like structure.</p>
<p><img alt="https://miro.medium.com/max/2000/1*1bcaVVjG_077zHVzGfHUyw.gif" src="https://miro.medium.com/max/2000/1*1bcaVVjG_077zHVzGfHUyw.gif"></p>
<p>In the above example, we have accessed the incremental.html file from our Node server and set the network speed to only 10kbps (from the Network panel). Since it will take a long time for the browser to load (download) this file (as it contains 1000 h1 elements), the browser constructs a DOM tree from the first few bytes and prints them on the screen (as it downloads the remaining content of the HTML file in the background).</p>
<p><img alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6e8ceed9-9af7-41a1-be77-3deb75b2b693/1_iFkRxUmwMKObC9hEqRiywQ.png" src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6e8ceed9-9af7-41a1-be77-3deb75b2b693/1_iFkRxUmwMKObC9hEqRiywQ.png"></p>
<p>If you have a look at the <strong>Performance</strong> chart of the above request, you will be able to see some <strong>events</strong> in the <strong>Timing</strong> row. These events are commonly known as <strong><a href="https://web.dev/user-centric-performance-metrics/#important-metrics-to-measure" rel="nofollow noopener noreferrer" target="_blank">performance metrics</a></strong>. When these events are placed <strong>as close as possible to each other</strong> and happen <strong>as early as possible</strong>, better the <strong>user experience</strong>.</p>
<blockquote>
<p>💡 Use the ⟳ icon in the Performance tab to capture a performance profile.</p>
</blockquote>
<p>The <code>FP</code> is an acronym of <strong>First Paint</strong>, which means the time at which the browser has started printing things on the screen (<em>could be as simple as the first pixel of the background color of the body</em>).</p>
<p>The <code>FCP</code> is an acronym of <strong>First Contentful Paint</strong> which means the time at which the browser has rendered the first pixel of the content such as <strong>text</strong> or <strong>image</strong>. The <code>LCP</code> is an acronym of the <strong>Largest Contentful Paint</strong> which means the time at which the browser has rendered large pieces of text or image.</p>
<blockquote>
<p>💡 You might have heard about FMP (first meaningful paint) which is also a metric similar to LCP but it has been dropped from Chrome in favor of LCP.</p>
</blockquote>
<p>The <code>L</code> stands for the <code>[onload](https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event)</code> event which is emitted by the browser on the <code>window</code> object. Similarly, the <code>DCL</code> stands for the <code>[DOMContentLoaded](https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event)</code> event which is emitted on the <code>document</code> object but it bubbles up to <code>window</code>, hence you can listen to it on the <code>window</code> as well. These events are a little complex to understand, so we will discuss them in a bit.</p>
<p>Whenever the browser encounters an <strong>external resource</strong> such as a <strong>script</strong> file (<em>JavaScript</em>) via <code>&lt;script src="*url*">&lt;/script></code> element, a <strong>stylesheet</strong> file (<em>CSS</em>) via <code>&lt;link rel="stylesheet" href="*url*"/></code> tag, an image file via <code>&lt;img src="*url*" /></code> element or any other external resource, the browser will start the download of that file in the background (<em>away from the <strong>main thread</strong> of the JavaScript execution</em>).</p>
<p>The most important thing to remember is the DOM parsing normally happens on the <strong>main thread</strong>. So if the main JavaScript execution thread is busy, DOM parsing will not progress until the thread is free. Why that’s so important you may ask? Because <code>script</code> elements are <strong>parser-blocking</strong>. Every external file requests such as <strong>image</strong>, <strong>stylesheet</strong>, <strong>pdf</strong>, <strong>video</strong>, etc. do not block DOM construction (<em>parsing</em>) except script (<em><code>.js</code></em>) file requests.</p>
<h2 id="parser-blocking-scripts"><a href="#parser-blocking-scripts" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a><strong>Parser-Blocking Scripts</strong></h2>
<p>A <strong>parser-blocking script</strong> is a script (<em>JavaScript</em>) file/code that stops the parsing of the HTML. When the browser encounters a <code>script</code> element, if it an embedded script, then it will <strong>execute</strong> that script first and then continue parsing the HTML to construct the DOM tree. So all <strong>embedded scripts are parser-blocking</strong>, end of the discussion.</p>
<p>If the <code>script</code> element is an <strong>external script file</strong>, the browser will start the download of the external script file off the main thread but it will <strong>halt the execution</strong> of the main thread until that file is downloaded. That means no more DOM parsing until the script file is downloaded.</p>
<p>Once the script file is downloaded, the browser will first <strong>execute</strong> the downloaded script file on the main thread (<em>obviously</em>) and then continue with the DOM parsing. If the browser again finds another <code>script</code> element in HTML, it will perform the same operation. So why browser has to halt the DOM parsing until JavaScript is downloaded and executed?</p>
<p>The browser exposes DOM API to the JavaScript runtime, which means we can access and manipulate DOM elements from the JavaScript. This is how dynamic web frameworks such as <strong>React</strong> and <strong>Angular</strong> works. But if the browser wishes to run DOM parsing and script execution <strong>parallelly</strong>, then there could be <strong><a href="https://stackoverflow.com/questions/34510/what-is-a-race-condition" rel="nofollow noopener noreferrer" target="_blank">race conditions</a></strong> between the DOM parser thread and the main thread which is why DOM parsing must happen on the main thread.</p>
<p>However, halting DOM parsing while the script file is being downloaded in the background is totally unnecessary in most cases. Hence HTML5 gives us the <code>[async](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script)</code> attribute for the <code>script</code> tag. When DOM parser encounters an external <code>script</code> element with <code>async</code> attribute, it will not halt the parsing process while the script file is being downloaded in the background. But once the file is downloaded, the parsing will halt and the script (<em>code</em>) will be executed.</p>
<p>We also have a magical <code>defer</code> attribute for the <code>script</code> element which works similar to the <code>async</code> attribute but unlike the <code>async</code> attribute, the script <strong>doesn’t execute</strong> even when the file is fully downloaded. All <code>defer</code> scripts are executed once the parser has parsed all HTML which means the DOM tree is fully constructed. Unlike <code>async</code> scripts, all <code>defer</code> scripts are executed in the order they appear in the HTML document (<em>or DOM tree</em>).</p>
<p>All normal scripts (<em>embedded or external</em>) are <strong>parser-blocking</strong> as they halt the construction of DOM. All <code>async</code> scripts (<em>AKA asynchronous scripts</em>) do not block parser until they are downloaded. As soon as an <code>async</code> script is downloaded, it becomes parser-blocking. However, all <code>defer</code> scripts (<em>AKA deferred scripts</em>) are <strong>non-parser-blocking</strong> script as they do not block the parser and execute after the DOM tree is fully constructed.</p>
<p><img alt="https://miro.medium.com/max/2000/1*5xdQ1j6Ai2PZYCRQuXM5wg.gif" src="https://miro.medium.com/max/2000/1*5xdQ1j6Ai2PZYCRQuXM5wg.gif"></p>
<p>In the above example, the parser-blocking.html file contains a parser-blocking script after 30 elements which is why the browser displays 30 elements at first, stops the DOM parsing, and starts loading the script file. The second script file doesn't block the parsing as it has the defer attribute, so it will execute once the DOM tree is fully constructed.</p>
<p><img alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/89284082-b80c-4067-8cfb-18cf173b964c/1_pxkIXo-LvXEkGaJJeR9cyA.png" src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/89284082-b80c-4067-8cfb-18cf173b964c/1_pxkIXo-LvXEkGaJJeR9cyA.png"></p>
<p>If we take a look at the <strong>Performance</strong> panel, the <code>FP</code> and <code>FCP</code> happens as soon as possible (<em>hidden behind the <strong>Timings</strong> label</em>) since the browser starts to build a DOM tree as soon as some HTML content is available, hence it can render some pixels on the screen.</p>
<p>The <code>LCP</code> happens after 5 seconds because the parser-blocking script has blocked the DOM parsing for 5 seconds (<em>its download time</em>) and only 30 text elements were rendered on the screen when the DOM parser was blocked which is not sufficient to be called as the largest contentful paint (<em>according to Google Chrome standards</em>). But once the script was downloaded and executed, DOM parsing resumed and large content was rendered on the screen which led to the firing of <code>LCP</code> event.</p>
<blockquote>
<p>💡 Parser-blocking is also referred to as render-blocking as rendering won’t happen unless the DOM tree is constructed, but these two are quite different things as we will see in a bit.</p>
</blockquote>
<p>Some browsers may incorporate a <strong><a href="https://developer.mozilla.org/en-US/docs/Glossary/speculative_parsing" rel="nofollow noopener noreferrer" target="_blank">speculative parsing</a></strong> strategy where the HTML parsing (<em>but not the DOM tree construction</em>) is offloaded to a separate thread so that browser can read elements such as <code>link</code>(<em>CSS</em>), <code>script</code>, <code>img</code>, etc. and download these resources <strong>eagerly</strong>.</p>
<p>This is quite helpful if you have three <code>script</code> elements one after the other, but the browser won’t be able to start the download of the second script until the first script is downloaded as the DOM parser couldn’t read the second <code>script</code> element. We can fix this easily by using <code>async</code> tag but asynchronous scripts are not guaranteed to execute in order.</p>
<p>The reason it is called speculative parsing because the browser is making a <strong>speculation</strong> that a particular resource is expected to load in the future, so better load it now in the background. However, if some JavaScript manipulates DOM and removes/hides the element with an external resource, then speculation fails and these files were loaded for nothing. Tough.</p>
<blockquote>
<p>💡 Every browser has a mind of its own, so when or if speculative parsing will happen is not guaranteed. However, you can ask the browser to load some resources ahead of time using the <link rel="preload"> element.</p>
</blockquote>
<h2 id="render-blocking-css"><a href="#render-blocking-css" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a><strong>Render-Blocking CSS</strong></h2>
<p>As we learned, any external resource request except a parser-blocking script file doesn’t block the DOM parsing process. Hence CSS (<em>including embedded</em>) doesn’t block the DOM parser…(<em>wait for it</em>)…<strong>directly</strong>. Yes, <strong>CSS can block DOM parsing</strong> but for that, we need to understand the rendering processes.</p>
<p>The browser engines inside your browser construct the DOM tree from HTML content received as a text document from the server. Similarly, it constructs the <strong>CSSOM</strong> tree from the stylesheet content such as from an external CSS file or embedded (<em>as well as inline</em>) CSS in the HTML.</p>
<p>Both DOM and CSSOM tree constructions happen on the main thread and these trees are getting constructed <strong>concurrently</strong>. Together they form the <strong>Render Tree</strong> that is used to print things on the screen which is also getting built incrementally as the DOM tree is getting constructed.</p>
<p>As we have learned that DOM tree generation is <strong>incremental</strong> which means as the browser reads HTML, it will add DOM elements to the DOM tree. But that’s not the case with the CSSOM tree. Unlike the DOM tree, CSSOM tree construction is <strong><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path#CSS_Object_Model" rel="nofollow noopener noreferrer" target="_blank">not incremental</a></strong> and must happen in a specific manner.</p>
<p>When browser find <code>&lt;style></code> block, it will parse all the embedded CSS and update the CSSOM tree with new CSS (<em>style</em>) rules. After that, it will continue parsing the HTML in the normal manner. The same goes for inline styling.</p>
<p>However, things change drastically when the browser encounters an external stylesheet file. Unlike an external script file, an external stylesheet file is not parser-blocking resources, hence the browser can download it in the background silently and the DOM parsing will continue.</p>
<p>But unlike the HTML file (<em>for the DOM construction</em>), the browser won’t process the stylesheet file content one byte at a time. This is because browsers can’t build the CSSOM tree incrementally as it reads the CSS content. The reason for that is, a CSS rule at the end of the file might override a CSS rule written at the top of the file.</p>
<p>Hence if the browser starts constructing CSSOM incrementally as it parses the stylesheet content, it will lead to multiple renders of the <strong>Render Tree</strong> as the same CSSOM nodes are getting updated because of the <strong>style overrides rules</strong> that appear later in the stylesheet file. It would be an unpleasant user experience to see elements changing styles on the screen as CSS is getting parsed. Since CSS styles are <strong><a href="https://stackoverflow.com/a/1043046/2790983" rel="nofollow noopener noreferrer" target="_blank">cascading</a></strong>, one rule change can affect many elements.</p>
<p>Hence browsers do not process external CSS files incrementally and the CSSOM tree update happens at once after all the CSS rules in the stylesheet are processed. Once the CSSOM tree update is completed, then the <strong>Render Tree</strong> is updated which then is rendered on the screen.</p>
<p>CSS is a <strong>render-blocking</strong> resource. Once the browser makes a request to fetch an external stylesheet, the <strong>Render Tree construction is halted</strong>. Therefore the <strong>Critical Rendering Path</strong> (<em>CRP</em>) is also stuck and nothing is getting rendered on the screen as demonstrated below. However, the DOM tree construction is still undergoing while the stylesheet is being downloaded in the background.</p>
<p><img alt="https://miro.medium.com/max/2000/1*y3QmSfyergjmVV32nH7tPA.gif" src="https://miro.medium.com/max/2000/1*y3QmSfyergjmVV32nH7tPA.gif"></p>
<p>A browser <strong>could have</strong> used an older state of the CSSOM tree to generate <strong>Render Tree</strong> as HTML is getting parsed to render things on the screen incrementally. But this has a huge downside. In this case, once the stylesheet is downloaded and parsed, and CSSOM is updated, Render Tree will be updated and rendered on the screen. Now the Render Tree nodes generated with older CSSOM will be <strong>repainted with new styles</strong> and it could also lead to <strong><a href="https://webkit.org/blog/66/the-fouc-problem/" rel="nofollow noopener noreferrer" target="_blank">Flash of Unstyled Content</a></strong> (<em>FOUC</em>) which is is very bad for UX.</p>
<p>Hence browsers will wait until the stylesheet is loaded and parsed. Once the stylesheet is parsed and CSSOM is updated, the Render Tree is updated, and <strong>CRP is unblocked</strong> which leads to the paint of Render Tree on the screen. Due to this reason, it is recommended to load all external stylesheets as early as possible, possibly in the <code>head</code> section.</p>
<p>Let’s imagine a scenario where the browser has started parsing HTML and it encounters an external stylesheet file. It will start the download of the file in the background, block the CRP, and continue with the DOM parsing. But then it encounters a <code>script</code> tag. So it will start the download of the external script file and block the DOM parsing. Now the browser is sitting idle waiting for the stylesheet and script file to download completely.</p>
<p>But this time, the external script file has been <strong>downloaded completely</strong> while the stylesheet is still being downloaded in the background. Should the browser execute the script file? Is there any harm doing that?</p>
<p>As we know, CSSOM provides a high-level JavaScript API to interact with the <strong>styles</strong> of the DOM elements. For example, you can read or update the background color of a DOM element using <code>elem.style.backgroundColor</code> property. The <code>style</code> object associated the <code>elem</code> element exposes the CSSOM API and there are many other APIs to do the same (<em>read this <a href="https://css-tricks.com/an-introduction-and-guide-to-the-css-object-model-cssom/" rel="nofollow noopener noreferrer" target="_blank">css-tricks article</a></em>).</p>
<p>As a stylesheet is being downloaded background, JavaScript can still execute as the main thread is not being blocked by the loading stylesheet. If our JavaScript program accesses CSS properties of a DOM element (<em>through CSSOM API</em>), we will get a proper value (<em>as per the current state of CSSOM</em>).</p>
<p>But once the stylesheet is downloaded and parsed, which leads to CSSOM update, our JavaScript now has a bad CSS value of the element since the new CSSOM update could have changed the CSS properties of that DOM element. Due to this reason, it’s not safe to execute JavaScript while the stylesheet is being downloaded.</p>
<p>As per the <strong><a href="https://html.spec.whatwg.org/multipage/semantics.html#interactions-of-styling-and-scripting" rel="nofollow noopener noreferrer" target="_blank">HTML5 specification</a></strong>, the browser may download a script file but it will not execute it unless all previous stylesheets are parsed. When a stylesheet blocks the execution of a script, it is called a <strong>script-blocking</strong> stylesheet or a <strong>script-blocking</strong> CSS.</p>
<p><img alt="https://miro.medium.com/max/2000/1*atsh0R6Do25SriYvvskkgA.gif" src="https://miro.medium.com/max/2000/1*atsh0R6Do25SriYvvskkgA.gif"></p>
<p>In the above example, the <code>[script-blocking.html](https://github.com/course-one/browser-rendering-test/blob/master/html/script-blocking.html)</code> contains a <code>link</code> tag (<em>for an external stylesheet</em>) followed by a <code>script</code> tag (<em>for an external JavaScript</em>). Here the script gets downloaded really fast without any delay but the stylesheet takes 6 seconds to download. Hence, even though the script is downloaded completely as we can see from the <strong>Network</strong> panel, it wasn’t executed by the browser immediately. Only after the stylesheet is loaded, we see the <code>Hello World</code> messaged logged by the script.</p>
<blockquote>
<p>💡 Like async or defer attribute makes script element non-parser-blocking, an external stylesheet can also be marked as non-render-blocking using the media attribute. Using the media attribute value, the browser can make a smart decision when to load the stylesheet.</p>
</blockquote>
<h2 id="documents-domcontentloaded-event"><a href="#documents-domcontentloaded-event" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a><strong>Document’s <code>DOMContentLoaded</code> Event</strong></h2>
<p>The <code>[DOMContentLoaded](https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event)</code> (<em><strong>DCL</strong></em>) event marks a point in time when the browser has constructed a complete DOM tree from all the available HTML. But there are a lot of factors involved that can change when the <code>DCL</code> event is fired.</p>
<div class="nuxt-content-highlight"><pre class="line-numbers language-text"><code>document.addEventListener( 'DOMContentLoaded', function(e) {
    console.log( 'DOM is fully parsed!' );
} );
</code></pre></div>
<p>If our HTML doesn’t contain any scripts, DOM parsing won’t get blocked and <code>DCL</code> will fire as quickly as the browser can parse the entire HTML. If we have parser-blocking scripts, then <code>DCL</code> has to wait until all parser-blocking scripts are downloaded and executed.</p>
<p>Things get a little complicated when stylesheets are thrown into the picture. Even though you have no external scripts, <code>DCL</code> will wait until all stylesheets are loaded. Since <code>DCL</code> marks a point in time when the entire DOM tree is ready, but DOM won’t be safe to access (<em>for the style information</em>) unless CSSOM is also fully constructed. Hence most browsers wait until all external stylesheets are loaded and parsed.</p>
<p>Script-blocking stylesheet will obviously delay the <code>DCL</code>. In this case, since the script is waiting for the stylesheet to load, the DOM tree is not getting constructed.</p>
<p><code>DCL</code> is one of the website performance metrics. We should optimize the <code>DCL</code> to be as small as possible (<em>the time at which it occurs</em>). One of the best practices is to use <code>defer</code> and <code>async</code> tag for <code>script</code> element whenever possible so that browser can perform other things while scripts are being downloaded in the background. Second, we should optimize the <strong>script-blocking</strong> and <strong>render-blocking</strong> stylesheets.</p>
<h2 id="windows-load-event"><a href="#windows-load-event" aria-hidden="true" tabindex="-1"><span class="icon icon-link"></span></a><strong>Window’s <code>load</code> event</strong></h2>
<p>As we know JavaScript can block DOM tree generation but that’s not the case with external stylesheets and files such as images, videos, etc.</p>
<p>The <code>DOMContentLoaded</code> event marks a point in time when the DOM tree is fully constructed and it is safe to access, the <code>window.onload</code> event marks a point in time when external stylesheets and files are downloaded and our web application (<em>complete</em>) has finished downloading.</p>
<div class="nuxt-content-highlight"><pre class="line-numbers language-jsx"><code><span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span> <span class="token string">'load'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> <span class="token string">'Page is fully loaded!'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>
</code></pre></div>
<p><img alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9d1df2a7-3095-4009-a986-52f01515e6fe/1_DuLBecXpJjFh1qnakXjWWg.png" src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9d1df2a7-3095-4009-a986-52f01515e6fe/1_DuLBecXpJjFh1qnakXjWWg.png"></p>
<p>In the above example, the <code>[rendering.html](https://github.com/course-one/browser-rendering-test/blob/master/html/rendering.html)</code> file has an external stylesheet in the <code>head</code> that takes around 5 seconds to download. Since it’s in the <code>head</code> section, the <code>FP</code> and <code>FCP</code> occurs after 5 seconds since the stylesheet will block the rendering of any content below it (<em>as it blocks CRP</em>).</p>
<p>After that, we have an <code>img</code> element that loads an image that takes around 10 seconds to download. So the browser will keep downloading this file in the background and move on with the DOM parsing and rendering (<em>as an external image resource is neither parser-blocking nor render-blocking</em>).</p>
<p>Next, we have three external JavaScript files and they take 3s, 6s, and 9s to download respectively and most importantly, they are not <code>async</code>. This means the total load time should be close to <strong>18 seconds</strong> as the subsequent script won’t start downloading before the previous one is executed. However, looking at the <code>DCL</code> event, our browser seemed to have used the <strong>speculative strategy</strong> to eagerly download the script files so the total time to load is close to <strong>9 seconds</strong>.</p>
<p>Since the last file to download that can affect the <code>DCL</code> is the last script file with the load time of <strong>9 seconds</strong> (<em>since stylesheet has already been downloaded in 5 seconds</em>), the <code>DCL</code> event occurs around <strong>9.1 seconds</strong>.</p>
<p>We also had another external resource which was the image file and it kept loading in the background. Once it was fully downloaded (<em>which takes 10 seconds</em>), the window’s <code>load</code> event was fired after <strong>10.2 seconds</strong> which marks that the webpage (<em>application</em>) is fully loaded.</p>
<p>Github repo:</p>
<p><a href="https://github.com/course-one/browser-rendering-test/tree/master" rel="nofollow noopener noreferrer" target="_blank">https://github.com/course-one/browser-rendering-test/tree/master</a></p></div></div> <footer class="footer has-background-primary" data-v-5678ae99><div class="links" data-v-5678ae99><a href="https://github.com/nuong" target="blank" class="link" data-v-5678ae99><img src="/mixin-hub/_nuxt/img/github.438c172.png" width="28" alt data-v-5678ae99></a> <a href="https://www.linkedin.com/in/kate-n-nguyen-38b33298/" target="blank" class="link" data-v-5678ae99><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAsQAAALEBxi1JjQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAFQSURBVFiF7de/SgNBEMfxj0GwsBH/oCIIFpaKlZBXsBG7vICViI1g7QtY+Qr2VjYiqI1FJCjYCVaiCIqdiJBocSccS7zVcMkh5AfDMbOzt9+bPWZZWMAlmvjskTVRT9d22cOFQ6sPpDQV5ag1kJKUprK+/H8BvOEWH92CyPtLTzGS5s3iLpLfieUOrgSwO0UDxLZgMvCnIvkdKY/wCTUsYgvvkfw/W+l9YDAyfoTzjF/DEk5wnImvYRp7uJJ016qkajMxiLwSbQe5B2l8N4hvYqzNu8dxk7dGUY1oHy9t4s9Yz5tYFMAnNnCYPrO6kDSytor9A79VTVIFWJWU/Swzfo35dhOLqkA18JcD//WniUUBDAX+cOC3ug3QsfoAfYDYYXQvORG/NYdRPOIhE5/FRMaPjf8aoOsqfQv6ABU5bbIHalXQKBGgQXJFrivpev4F107qCe7w/DMAAAAASUVORK5CYII=" width="28" alt data-v-5678ae99></a></div> <div class="content has-text-right" data-v-5678ae99><p class="has-text-white" data-v-5678ae99><b data-v-5678ae99>Develop by</b> Kate.n.nguyen - Website is in development.
		</p></div></footer></div></div></div><script defer src="/mixin-hub/_nuxt/static/1632317493/collection/how-the-browser-renders-a-web-page-dom-cssom-and-rendering/state.js"></script><script src="/mixin-hub/_nuxt/dea7c48.js" defer></script><script src="/mixin-hub/_nuxt/9955695.js" defer></script><script src="/mixin-hub/_nuxt/3acc980.js" defer></script><script src="/mixin-hub/_nuxt/ffbb57e.js" defer></script><script src="/mixin-hub/_nuxt/c4e6356.js" defer></script>
  </body>
</html>
