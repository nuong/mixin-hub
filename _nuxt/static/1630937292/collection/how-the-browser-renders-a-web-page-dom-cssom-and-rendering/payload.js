__NUXT_JSONP__("/collection/how-the-browser-renders-a-web-page-dom-cssom-and-rendering", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_,a$,ba,bb,bc,bd,be,bf,bg,bh,bi,bj,bk,bl,bm,bn,bo,bp,bq,br,bs,bt,bu,bv,bw,bx,by,bz,bA,bB,bC,bD,bE,bF,bG,bH,bI,bJ,bK,bL,bM,bN,bO,bP,bQ,bR,bS,bT,bU,bV,bW,bX,bY,bZ,b_,b$){return {data:[{article:{slug:"how-the-browser-renders-a-web-page-dom-cssom-and-rendering",description:"In this article, we will deep dive into DOM and CSSOM to understand how the browser renders a webpage. The browser blocks some rendering of a webpage until certain resources are loaded first while other resources are loaded asynchronously.",title:"How the browser renders a web page? — DOM, CSSOM, and Rendering",img:"https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1610862169846-80fb009ed591?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=934&q=80",alt:"my first blog post",author:{name:as,bio:as,image:as,source:"https:\u002F\u002Fmedium.com\u002Fjspoint\u002Fhow-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969"},toc:[{id:bJ,depth:P,text:aO},{id:aI,depth:P,text:aJ},{id:aL,depth:P,text:S},{id:aN,depth:L,text:aP},{id:aQ,depth:P,text:aV},{id:aW,depth:P,text:aY},{id:a$,depth:L,text:ba},{id:bc,depth:L,text:bg},{id:bl,depth:L,text:bm},{id:bo,depth:P,text:bq},{id:bs,depth:L,text:bt},{id:bD,depth:L,text:bT},{id:bW,depth:L,text:"Document’s DOMContentLoaded Event"},{id:aH,depth:L,text:"Window’s load event"}],body:{type:"root",children:[{type:b,tag:f,props:{},children:[{type:a,value:"Whenever you are developing a website, there are certain things that are very essential for a good user experience. Some of the common problems a website may encounter could be slow loading of the resources, waiting for unnecessary files to download on initial render, a flash of unstyled content (FOUC), etc. To avoid such problems, we need to understand the lifecycle of how a browser renders a typical webpage."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"First, we need to understand what DOM is. When a browser sends a request to a server to fetch an HTML document, the server returns an HTML page in binary stream format which is basically a text file with the response header Content-Type set to the value text\u002Fhtml; charset=UTF-8."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Here text\u002Fhtml is a MIME Type which tells the browser that it is an HTML document and charset=UTF-8 tells the browser that it is encoded in UTF-8 character encoding. Using this information, the browser can convert the binary format into a readable text file. This has shown below in the screenshot."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:$,src:"https:\u002F\u002Fs3.us-west-2.amazonaws.com\u002Fsecure.notion-static.com\u002F19635c9a-eede-4be2-a81c-7a64c6cfb5a7\u002F1_Tm-HPhmGA0BL7HIj38H8Qw.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210125T151038Z&X-Amz-Expires=86400&X-Amz-Signature=f47526ca66a355798c6ae5ea958d7c04c855d2925b443eeca60cfa8732a73179&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%221_Tm-HPhmGA0BL7HIj38H8Qw.png%22"},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"If this header is missing, the browser would not understand how to process the file and it will render in plain text format. But if everything is OK, after this conversion, the browser can start reading the HTML document. A typical HTML document could look like this."}]},{type:a,value:d},{type:b,tag:F,props:{className:[af]},children:[{type:b,tag:ag,props:{className:[ah,"language-html"]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[e,"doctype"]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:"\u003C!"}]},{type:b,tag:c,props:{className:[e,"doctype-tag"]},children:[{type:a,value:"DOCTYPE"}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,"name"]},children:[{type:a,value:"HTML"}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:H}]},{type:a,value:aj}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:z},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:H}]},{type:a,value:ab}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:Y},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:H}]},{type:a,value:aA}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:"Rendering Test"},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:K}]},{type:a,value:aA}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:aF},{type:b,tag:c,props:{className:[e,aG]},children:[{type:a,value:"\u003C!-- stylesheet --\u003E"}]},{type:a,value:Y},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:H}]},{type:a,value:_}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,aq]},children:[{type:a,value:"rel"}]},{type:b,tag:c,props:{className:[e,ap]},children:[{type:b,tag:c,props:{className:[e,i,ao]},children:[{type:a,value:am}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:N}]},{type:a,value:az},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:N}]}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,aq]},children:[{type:a,value:"href"}]},{type:b,tag:c,props:{className:[e,ap]},children:[{type:b,tag:c,props:{className:[e,i,ao]},children:[{type:a,value:am}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:N}]},{type:a,value:".\u002Fstyle.css"},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:N}]}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:"\u002F\u003E"}]}]},{type:a,value:z},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:K}]},{type:a,value:ab}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:z},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:H}]},{type:a,value:al}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:Y},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:H}]},{type:a,value:F}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,aq]},children:[{type:a,value:ac}]},{type:b,tag:c,props:{className:[e,ap]},children:[{type:b,tag:c,props:{className:[e,i,ao]},children:[{type:a,value:am}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:N}]},{type:a,value:"container"},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:N}]}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:aR},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:H}]},{type:a,value:aS}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:"Hello World!"},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:K}]},{type:a,value:aS}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:aR},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:H}]},{type:a,value:f}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:"This is a sample paragraph."},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:K}]},{type:a,value:f}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:Y},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:K}]},{type:a,value:F}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:aF},{type:b,tag:c,props:{className:[e,aG]},children:[{type:a,value:"\u003C!-- script --\u003E"}]},{type:a,value:Y},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:H}]},{type:a,value:t}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,aq]},children:[{type:a,value:"src"}]},{type:b,tag:c,props:{className:[e,ap]},children:[{type:b,tag:c,props:{className:[e,i,ao]},children:[{type:a,value:am}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:N}]},{type:a,value:".\u002Fmain.js"},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:N}]}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:b,tag:c,props:{className:[e,t]},children:[]},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:K}]},{type:a,value:t}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:z},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:K}]},{type:a,value:al}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,l]},children:[{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:K}]},{type:a,value:aj}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:r}]}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"In the above document, our webpage is dependent on style.css to provide styles to HTML elements and main.js to perform some JavaScript operations. With some neat CSS styles, our above webpage will look like this."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:$,src:"https:\u002F\u002Fs3.us-west-2.amazonaws.com\u002Fsecure.notion-static.com\u002F7a15ce6e-a83e-49ec-97f3-7ec955a0852c\u002F1_3bFOsAXQPJtczaQcQcVZ1A.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210125T151152Z&X-Amz-Expires=86400&X-Amz-Signature=da8f973725949ba7d4edeb2894a73866915333426eaf69bf20277a8340e0f7cd&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%221_3bFOsAXQPJtczaQcQcVZ1A.png%22"},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"But the question still stands, how does a browser render this beautiful-looking webpage from a simple HTML file which contains nothing but text? For that, we need to understand what is DOM, CSSOM, and Render Tree?"}]},{type:a,value:d},{type:b,tag:T,props:{id:bJ},children:[{type:b,tag:k,props:{href:"#document-object-model-dom",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:a,value:aO}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"When the browser reads HTML code, whenever it encounters an HTML element like "},{type:b,tag:h,props:{},children:[{type:a,value:aj}]},{type:a,value:A},{type:b,tag:h,props:{},children:[{type:a,value:al}]},{type:a,value:A},{type:b,tag:h,props:{},children:[{type:a,value:F}]},{type:a,value:" etc., it creates a JavaScript object called a "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FNode",rel:[o,n,m],target:p},children:[{type:a,value:"Node"}]}]},{type:a,value:". Eventually, all HTML elements will be converted to JavaScript objects."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Since every HTML element has different properties, the Node object will be created from different classes ("},{type:b,tag:j,props:{},children:[{type:a,value:"constructor functions"}]},{type:a,value:"). For example, the Node object for the "},{type:b,tag:h,props:{},children:[{type:a,value:F}]},{type:a,value:" element is created from "},{type:b,tag:h,props:{},children:[{type:a,value:bE}]},{type:a,value:" which "},{type:b,tag:g,props:{},children:[{type:a,value:"inherits"}]},{type:a,value:" "},{type:b,tag:h,props:{},children:[{type:a,value:b$}]},{type:a,value:" class. For our earlier HTML document, we can visualize these nodes using a simple test as below."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:$,src:"https:\u002F\u002Fs3.us-west-2.amazonaws.com\u002Fsecure.notion-static.com\u002F2ded69d2-bd4e-4548-8d9f-ca3d7360f03b\u002F1_DmxJT96ZM3ob8TsgCFUJzw.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210125T151225Z&X-Amz-Expires=86400&X-Amz-Signature=882abd1773590dc6f3f3b5630b1e93e97701314cb1caa530cc5dd7bf2b4e99e7&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%221_DmxJT96ZM3ob8TsgCFUJzw.png%22"},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"The browser comes with built-in classes like "},{type:b,tag:h,props:{},children:[{type:a,value:bE}]},{type:a,value:A},{type:b,tag:h,props:{},children:[{type:a,value:"[HTMLScriptElement](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FHTMLScriptElement)"}]},{type:a,value:A},{type:b,tag:h,props:{},children:[{type:a,value:b$}]},{type:a,value:bM}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"After the browser has created Nodes from the HTML document, it has to create a "},{type:b,tag:g,props:{},children:[{type:a,value:"tree-like structure"}]},{type:a,value:" of these node objects. Since our HTML elements in the HTML file are nested inside each other, the browser needs to replicate that but using Node objects it has previously created. This will help the browser efficiently render and manage the webpage throughout its lifecycle."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:$,src:"https:\u002F\u002Fs3.us-west-2.amazonaws.com\u002Fsecure.notion-static.com\u002Ffa30718b-f4e6-4863-aedb-50c789ea9aa0\u002F1_YSA8lCfCVPn3d6GWAVokrA.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210125T151254Z&X-Amz-Expires=86400&X-Amz-Signature=888fb488d33d1327b25177a2bf7f1964e330e77c5ac0b3aebc14af9d4e766420&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%221_YSA8lCfCVPn3d6GWAVokrA.png%22"},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"A DOM tree for our earlier HTML document looks like above. A DOM tree starts from the topmost element which is html element and branches out as per the occurrence and nesting of HTML elements in the document. Whenever an HTML element is found, it creates a DOM node (Node) object from its respective class (constructor function)."}]},{type:a,value:d},{type:b,tag:B,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"💡 A DOM node doesn’t always have to be an HTML element. When the browser creates a DOM tree, it also saves things like comments, attributes, text as separate nodes in the tree. But for the simplicity, we will just consider DOM nodes for HTML elements AKA DOM element. Here is the list of all DOM node types."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"You can visualize the DOM tree in Google Chrome DevTools Console as shown below. This will show you the hierarchy of DOM elements (a high-level view of DOM tree) with properties of each DOM element."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:$,src:"https:\u002F\u002Fs3.us-west-2.amazonaws.com\u002Fsecure.notion-static.com\u002Fb4ad7149-1c5d-4f4b-83dd-a569cd92f281\u002F1_Uo2wfq060OMSLyTTCm2zFw.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210125%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210125T151317Z&X-Amz-Expires=86400&X-Amz-Signature=eb5b2e1b375f88e236cff36893c47ddd87ff9a4649d35083081736bd24fae29c&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%221_Uo2wfq060OMSLyTTCm2zFw.png%22"},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"JavaScript doesn’t understand what DOM is, it is not part of the JavaScript specifications. DOM is a high-level Web API provided by the browser to efficiently render a webpage and expose it publically for the developer to dynamically manipulate DOM elements for various purposes."}]},{type:a,value:d},{type:b,tag:B,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"💡 Using DOM API, developers can add or remove HTML elements, change its appearance or bind event listeners. Using DOM API, HTML elements can be created or cloned in memory and maniuplated without affecting the rendered DOM tree. This gives developers the ability to construct highly dynamic web page with rich user experience."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:T,props:{id:aI},children:[{type:b,tag:k,props:{href:"#css-object-model-cssom",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:a,value:aJ}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"When we design a website, our intentions are to make it as good looking as possible. And we do that by providing some styles to HTML elements. In the HTML page, we provide styles to HTML elements using CSS which stands for Cascading Style Sheets. Using CSS selectors, we can target DOM elements and set a value to style property such as color or font-size."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"There are different methods of applying styles to HTML elements like using an external CSS file, with embedded CSS using "},{type:b,tag:at,props:{},children:[{type:a,value:" tag, with an inline method using the style attribute on HTML elements or using JavaScript. But in the end, the browser has to do the heavy lifting of applying CSS styles to the DOM elements."}]},{type:a,value:d}]},{type:b,tag:f,props:{},children:[{type:a,value:"Let’s say, for our earlier example, we are going to use the below CSS styles (this is not the CSS used for the card shown in the screenshot). For the sake of simplicity, we are not going to be bothered about how we are importing the CSS styles in the HTML page."}]},{type:a,value:d},{type:b,tag:F,props:{className:[af]},children:[{type:b,tag:ag,props:{className:[ah,"language-css"]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[e,X]},children:[{type:a,value:aj}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:R}]},{type:a,value:z},{type:b,tag:c,props:{className:[e,E]},children:[{type:a,value:"padding"}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:I}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,U]},children:[{type:a,value:aK}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:C}]},{type:a,value:z},{type:b,tag:c,props:{className:[e,E]},children:[{type:a,value:"margin"}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:I}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,U]},children:[{type:a,value:aK}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:C}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:W}]},{type:a,value:ad},{type:b,tag:c,props:{className:[e,X]},children:[{type:a,value:al}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:R}]},{type:a,value:z},{type:b,tag:c,props:{className:[e,E]},children:[{type:a,value:ax}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:I}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,U]},children:[{type:a,value:"14"}]},{type:b,tag:c,props:{className:[e,ak]},children:[{type:a,value:ae}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:C}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:W}]},{type:a,value:ad},{type:b,tag:c,props:{className:[e,X]},children:[{type:b,tag:c,props:{className:[e,ac]},children:[{type:a,value:aB}]}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:R}]},{type:a,value:z},{type:b,tag:c,props:{className:[e,E]},children:[{type:a,value:"width"}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:I}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,U]},children:[{type:a,value:"300"}]},{type:b,tag:c,props:{className:[e,ak]},children:[{type:a,value:ae}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:C}]},{type:a,value:z},{type:b,tag:c,props:{className:[e,E]},children:[{type:a,value:"height"}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:I}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,U]},children:[{type:a,value:"200"}]},{type:b,tag:c,props:{className:[e,ak]},children:[{type:a,value:ae}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:C}]},{type:a,value:z},{type:b,tag:c,props:{className:[e,E]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:I}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,Z]},children:[{type:a,value:"black"}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:C}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:W}]},{type:a,value:ad},{type:b,tag:c,props:{className:[e,X]},children:[{type:b,tag:c,props:{className:[e,ac]},children:[{type:a,value:aB}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,aT]},children:[{type:a,value:r}]},{type:a,value:" h1"}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:R}]},{type:a,value:z},{type:b,tag:c,props:{className:[e,E]},children:[{type:a,value:Z}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:I}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,Z]},children:[{type:a,value:"gray"}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:C}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:W}]},{type:a,value:ad},{type:b,tag:c,props:{className:[e,X]},children:[{type:b,tag:c,props:{className:[e,ac]},children:[{type:a,value:aB}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,aT]},children:[{type:a,value:r}]},{type:a,value:" p"}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:R}]},{type:a,value:z},{type:b,tag:c,props:{className:[e,E]},children:[{type:a,value:ax}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:I}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,U]},children:[{type:a,value:"12"}]},{type:b,tag:c,props:{className:[e,ak]},children:[{type:a,value:ae}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:C}]},{type:a,value:z},{type:b,tag:c,props:{className:[e,E]},children:[{type:a,value:"display"}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:I}]},{type:a,value:" none"},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:C}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:W}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"After constructing the DOM, the browser reads CSS from all the sources ("},{type:b,tag:j,props:{},children:[{type:a,value:"external, embedded, inline, user-agent, etc."}]},{type:a,value:") and construct a "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FCSS_Object_Model",rel:[o,n,m],target:p},children:[{type:a,value:aU}]}]},{type:a,value:". CSSOM stands for "},{type:b,tag:g,props:{},children:[{type:a,value:"CSS Object Model"}]},{type:a,value:" which is a Tree Like structure just like DOM."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Each node in this tree contains CSS style information that will be applied to DOM elements that it target ("},{type:b,tag:j,props:{},children:[{type:a,value:"specified by the selector"}]},{type:a,value:"). CSSOM, however, does not contain DOM elements which can’t be printed on the screen like "},{type:b,tag:h,props:{},children:[{type:a,value:"\u003Cmeta\u003E"}]},{type:a,value:A},{type:b,tag:h,props:{},children:[{type:a,value:"\u003Cscript\u003E"}]},{type:a,value:A},{type:b,tag:h,props:{},children:[{type:a,value:"\u003Ctitle\u003E"}]},{type:a,value:bM}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"As we know, most of the browser comes with its own stylesheet which is called as "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F12582624\u002Fwhat-is-a-user-agent-stylesheet",rel:[o,n,m],target:p},children:[{type:a,value:"user agent stylesheet"}]}]},{type:a,value:", the browser first computes final CSS properties for DOM element by overriding user agent styles with CSS provided by the developer properties ("},{type:b,tag:j,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FCSS\u002FSpecificity",rel:[o,n,m],target:p},children:[{type:a,value:"using specificity rules"}]}]},{type:a,value:") and then construct a node."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Even if a CSS property ("},{type:b,tag:j,props:{},children:[{type:a,value:"such as "},{type:b,tag:h,props:{},children:[{type:a,value:"[display](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FCSS\u002Fdisplay)"}]}]},{type:a,value:") for a particular HTML element isn’t defined by either the developer or the browser, its value is set to the "},{type:b,tag:g,props:{},children:[{type:a,value:"default value"}]},{type:a,value:" of that property as specified by the "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fwww.w3.org\u002FStyle\u002FCSS\u002F",rel:[o,n,m],target:p},children:[{type:a,value:"W3C CSS"}]}]},{type:a,value:" standard. While selecting the default value of a CSS property, some rules of "},{type:b,tag:g,props:{},children:[{type:a,value:"inheritance"}]},{type:a,value:" are used if a property qualifies for the inheritance as mentioned in the "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fwww.w3.org\u002FTR\u002FCSS1\u002F#inheritance",rel:[o,n,m],target:p},children:[{type:a,value:"W3C documentation"}]}]},{type:a,value:G}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"For example, "},{type:b,tag:h,props:{},children:[{type:a,value:Z}]},{type:a,value:Q},{type:b,tag:h,props:{},children:[{type:a,value:ax}]},{type:a,value:" among others inherits the value of the parent if these properties are missing for an HTML element. So you can imagine having these properties on an HTML element and all its children inheriting it. This is called "},{type:b,tag:g,props:{},children:[{type:a,value:"cascading of styles"}]},{type:a,value:" and that’s why CSS is an acronym of "},{type:b,tag:g,props:{},children:[{type:a,value:"Cascading Style Sheets"}]},{type:a,value:". This is the very reason why the browser constructs a CSSOM, a tree-like structure to "},{type:b,tag:g,props:{},children:[{type:a,value:"compute styles"}]},{type:a,value:" based on CSS cascading rules."}]},{type:a,value:d},{type:b,tag:B,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"💡 You can see the computed style of an HTML element by using Chrome DevTools console in Elements panel. Select any HTML element from the left panel and click on the computed tab on the right panel."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"We can visualize the CSSOM tree for our earlier example using the below diagram. For the sake of simplicity, we are going to ignore the user-agent styles and focus on CSS styles mentioned earlier."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:aX,src:aX},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"As you can see from the above diagram, our CSSOM tree does not contain elements which do not get printed on the screen like "},{type:b,tag:_,props:{},children:[]},{type:a,value:", "},{type:b,tag:aA,props:{},children:[{type:a,value:",  etc. CSS property values in the red colors are cascaded down from the top while property values in the gray are overriding the inherited values."}]},{type:a,value:d}]},{type:b,tag:T,props:{id:aL},children:[{type:b,tag:k,props:{href:"#render-tree",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:a,value:S}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Render-Tree is also a tree-like structure constructed by combining DOM and CSSOM trees together. The browser has to calculate the "},{type:b,tag:g,props:{},children:[{type:a,value:ay}]},{type:a,value:" of each visible element and "},{type:b,tag:g,props:{},children:[{type:a,value:"paint"}]},{type:a,value:" them on the screen, for that browser uses this Render-Tree. Hence, unless Render-Tree isn’t constructed, nothing is going to get printed on the screen which is why we need both DOM and CSSOM trees."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"As Render-Tree is a low-level representation of what will eventually get printed on the screen, it won’t contain nodes that do not hold any area in the pixel matrix. For example, "},{type:b,tag:h,props:{},children:[{type:a,value:aZ}]},{type:a,value:" elements have dimensions of "},{type:b,tag:h,props:{},children:[{type:a,value:"0px X 0px"}]},{type:a,value:", hence they won’t be present in Render-Tree."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:a_,src:a_},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"As you can see from the above diagram, Render-Tree combines DOM and CSSOM to generate a tree-like structure containing only the elements which will be printed on the screen."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Since in CSSOM, "},{type:b,tag:h,props:{},children:[{type:a,value:f}]},{type:a,value:" element situated inside "},{type:b,tag:h,props:{},children:[{type:a,value:F}]},{type:a,value:" has "},{type:b,tag:h,props:{},children:[{type:a,value:aZ}]},{type:a,value:" style set on it, it and its children won’t be present in Render-Tree, since it occupies no space on the screen. However, if you have elements with "},{type:b,tag:h,props:{},children:[{type:a,value:"visibility:hidden"}]},{type:a,value:ai},{type:b,tag:h,props:{},children:[{type:a,value:"opacity:0"}]},{type:a,value:", they will occupy space on the screen hence they will be present in the Render-Tree."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Unlike DOM API which gives access to the DOM elements in the DOM tree constructed by the browser, CSSOM is kept hidden from the user. But since the browser combines DOM and CSSOM to form the Render Tree, the browser exposes the CSSOM node of a DOM element by providing high-level API on the DOM element itself. This enables the developer to access or change the CSS properties of a CSSOM node."}]},{type:a,value:d},{type:b,tag:B,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"💡 Since manipulating styles of an element using JavaScript is beyond the scope of this article, so here is the link to awesome CSS Tricks Article that covers the broad spectrum of CSSOM API. We also have new CSS Typed Object API in JavaScript which is more accurate way to maniulate styles of an element."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:M,props:{id:aN},children:[{type:b,tag:k,props:{href:"#rendering-sequence",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:a,value:aP}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Now that we have a good understanding of what DOM, CSSOM, and Render-Tree are, let’s understand how a browse renders a typical webpage using them. Having a minimal understanding of this process is crucial for any web developers as it will help us design our website for maximum user experience (UX) and performance."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"When a web page is loaded, the browser first reads the HTML text and constructs DOM Tree from it. Then it processes the CSS whether that is inline, embedded, or external CSS and constructs the CSSOM Tree from it."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"After these trees are constructed, then it constructs the Render-Tree from it. Once the Render-Tree is constructed, then the browser starts the printing individual elements on the screen."}]},{type:a,value:d},{type:b,tag:T,props:{id:aQ},children:[{type:b,tag:k,props:{href:"#layout-operation",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:a,value:aV}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"The first browser creates the layout of each individual Render-Tree node. The layout consists of the "},{type:b,tag:g,props:{},children:[{type:a,value:"size of each node"}]},{type:a,value:" in pixels and where ("},{type:b,tag:j,props:{},children:[{type:a,value:"position"}]},{type:a,value:") it will be printed on the screen. This process is called "},{type:b,tag:g,props:{},children:[{type:a,value:ay}]},{type:a,value:" since the browser is calculating the layout information of each node."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"This process is also called "},{type:b,tag:g,props:{},children:[{type:a,value:bb}]},{type:a,value:ai},{type:b,tag:g,props:{},children:[{type:a,value:"browser reflow"}]},{type:a,value:" and it can also occur when you "},{type:b,tag:g,props:{},children:[{type:a,value:"scroll"}]},{type:a,value:A},{type:b,tag:g,props:{},children:[{type:a,value:"resize"}]},{type:a,value:" the window or "},{type:b,tag:g,props:{},children:[{type:a,value:"manipulate DOM"}]},{type:a,value:" elements. Here is a "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fstackoverflow.com\u002Fa\u002F27637245\u002F2790983",rel:[o,n,m],target:p},children:[{type:a,value:"list"}]}]},{type:a,value:" of events that can trigger the "},{type:b,tag:g,props:{},children:[{type:a,value:"layout\u002Freflow"}]},{type:a,value:" of the elements."}]},{type:a,value:d},{type:b,tag:B,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"💡 We should avoid the webpage going through multiple layout operations for minuscule reasons since it is a costly operation. Here is an article by Paul Lewis where he talks about how we can avoid complex and costly layout operations as well as layout thrashing."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:T,props:{id:aW},children:[{type:b,tag:k,props:{href:"#paint-operation",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:a,value:aY}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Until now we have a list of geometries that need to be printed on the screen. Since "},{type:b,tag:g,props:{},children:[{type:a,value:"elements"}]},{type:a,value:O},{type:b,tag:j,props:{},children:[{type:a,value:"or a sub-tree"}]},{type:a,value:") in the Render-Tree can overlap each other and they can have CSS properties that make them frequently change the look, position, or geometry ("},{type:b,tag:j,props:{},children:[{type:a,value:"such as animations"}]},{type:a,value:"), the browser creates a "},{type:b,tag:g,props:{},children:[{type:a,value:"layer"}]},{type:a,value:" for it."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Creating layers helps the browser efficiently perform painting operations throughout the lifecycle of a web page such as while scrolling or resizing the browser window. Having layers also help the browser correctly draw elements in the stacking order ("},{type:b,tag:j,props:{},children:[{type:a,value:"along the z-axis"}]},{type:a,value:") as they were intended by the developer."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Now that we have layers, we can combine them and "},{type:b,tag:g,props:{},children:[{type:a,value:"draw"}]},{type:a,value:" them on the screen. But the browser does not draw all the layers in a single go. Each layer is drawn separately first."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Inside each layer, the browser fills the individual pixels for whatever visible property the element has such as border, background color, shadow, text, etc. This process is also called as "},{type:b,tag:g,props:{},children:[{type:a,value:"rasterization"}]},{type:a,value:". To increase performance, the browser may use different "},{type:b,tag:g,props:{},children:[{type:a,value:"threads"}]},{type:a,value:" to perform rasterization."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"The analogy of layers in "},{type:b,tag:g,props:{},children:[{type:a,value:"Photoshop"}]},{type:a,value:" can be applied to how the browser renders a web page as well. You can visualize different layers on a web page from Chrome DevTools. Open DevTools and from "},{type:b,tag:g,props:{},children:[{type:a,value:"more tools"}]},{type:a,value:" options, select "},{type:b,tag:g,props:{},children:[{type:a,value:"Layers"}]},{type:a,value:". You can also visualize layer borders from the "},{type:b,tag:g,props:{},children:[{type:a,value:"Rendering"}]},{type:a,value:" panel."}]},{type:a,value:d},{type:b,tag:B,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"💡 Rasterization is normally done in CPU which makes it slow and expensive, but we now have new techniques to do it in GPU for performance enhancement. This intel article covers painting topic in details, it’s a must read. To understand concept of layers in great details, this is a must read article."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:M,props:{id:a$},children:[{type:b,tag:k,props:{href:"#compositing-operation",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:b,tag:g,props:{},children:[{type:a,value:ba}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Until now, we haven’t drawn a single pixel on the screen. What we have are different layers ("},{type:b,tag:j,props:{},children:[{type:a,value:"bitmap images"}]},{type:a,value:") that should be drawn on the screen in a specific order. In "},{type:b,tag:g,props:{},children:[{type:a,value:"compositing"}]},{type:a,value:" operations, these layers are sent to GPU to finally draw it on the screen."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Sending entire layers to draw is clearly inefficient because this has to happen every time there is a "},{type:b,tag:g,props:{},children:[{type:a,value:bb}]},{type:a,value:O},{type:b,tag:j,props:{},children:[{type:a,value:ay}]},{type:a,value:") or "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F2549296\u002Fwhats-the-difference-between-reflow-and-repaint",rel:[o,n,m],target:p},children:[{type:a,value:"repaint"}]}]},{type:a,value:". Hence, a layer is broken down into different "},{type:b,tag:g,props:{},children:[{type:a,value:"tiles"}]},{type:a,value:" which then will be drawn on the screen. You can also visualize these tiles in Chrome’s DevTool Rendering panel."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"From the above information, we can construct a sequence of events the browser goes through from a web page to render things on the screen from as simple as HTML and CSS text content."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:bd,src:bd},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"This sequence of events is also called the "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FPerformance\u002FCritical_rendering_path",rel:[o,n,m],target:p},children:[{type:a,value:"critical rendering path"}]}]},{type:a,value:G}]},{type:a,value:d},{type:b,tag:B,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"💡 Mariko Kosaka has written a beautiful article on this process with cool illustrations and broader explanations of each concept. Highly recommended."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:M,props:{id:bc},children:[{type:b,tag:k,props:{href:"#browser-engines",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:b,tag:g,props:{},children:[{type:a,value:bg}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"The job of creating DOM Tree, CSSOM Tree, and handle rendering logic is done using a piece of software called a "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FBrowser_engine",rel:[o,n,m],target:p},children:[{type:a,value:"Browser Engine"}]}]},{type:a,value:O},{type:b,tag:j,props:{},children:[{type:a,value:"also known as "},{type:b,tag:g,props:{},children:[{type:a,value:"Rendering Engine"}]},{type:a,value:ai},{type:b,tag:g,props:{},children:[{type:a,value:"Layout Engine"}]}]},{type:a,value:") which resides inside the browser. This browser engine contains all the necessary elements and logic to render a web page from HTML code to actual pixels on the screen."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"If you heard people talking about "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FWebKit",rel:[o,n,m],target:p},children:[{type:a,value:be}]}]},{type:a,value:", they were talking about a browser engine. "},{type:b,tag:g,props:{},children:[{type:a,value:be}]},{type:a,value:" is used by Apple’s Safari browser and was the default rendering engine for the Google Chrome browser. As of now, the "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FChromium_(web_browser)",rel:[o,n,m],target:p},children:[{type:a,value:"Chromium"}]}]},{type:a,value:" project uses "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FBlink_(browser_engine)",rel:[o,n,m],target:p},children:[{type:a,value:"Blink"}]}]},{type:a,value:" as the default rendering engine. "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fstackoverflow.com\u002Fa\u002F3468311\u002F2790983",rel:[o,n,m],target:p},children:[{type:a,value:"Here is a list"}]}]},{type:a,value:" of different browser engine used by some of the top web browsers."}]},{type:a,value:d},{type:b,tag:M,props:{id:bl},children:[{type:b,tag:k,props:{href:"#rendering-process-in-browsers",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:a,value:bm}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"We all know that JavaScript language is standardized through the "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FECMAScript",rel:[o,n,m],target:p},children:[{type:a,value:"ECMAScript"}]}]},{type:a,value:" standard, in fact since "},{type:b,tag:k,props:{href:"https:\u002F\u002Fdev.to\u002Ftheoutlander\u002Foracle-owns-the-trademark-to-javascript-1fil",rel:[o,n,m],target:p},children:[{type:a,value:"JavaScript is a registered trademark"}]},{type:a,value:", we just call it ECMAScript now. Therefore, every JavaScript engine provider such as "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"http:\u002F\u002Fv8.dev\u002F",rel:[o,n,m],target:p},children:[{type:a,value:"V8"}]}]},{type:a,value:A},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FChakra_(JavaScript_engine)",rel:[o,n,m],target:p},children:[{type:a,value:"Chakra"}]}]},{type:a,value:A},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FMozilla\u002FProjects\u002FSpiderMonkey",rel:[o,n,m],target:p},children:[{type:a,value:"Spider Monkey"}]}]},{type:a,value:", etc. has to obey the rules of this standard."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Having a standard gives us consistent JavaScript experience among all JavaScript runtimes such as browsers, Node, Deno, etc. This is great for the consistent and flawless development of JavaScript ("},{type:b,tag:j,props:{},children:[{type:a,value:"and web"}]},{type:a,value:") applications for multiple platforms."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"However, that’s not the case with how a browser renders things. HTML, CSS, or JavaScript, these languages are standardized by some entity or some organization. However, how a browser manages them together to render things on the screen is not standardized. The browser engine of Google Chrome might do things differently than the browser engine of Safari."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Therefore, it’s hard to predict the rendering sequence in a particular browser and the mechanism behind it. However, the "},{type:b,tag:k,props:{href:"https:\u002F\u002Fhtml.spec.whatwg.org\u002F",rel:[o,n,m],target:p},children:[{type:a,value:bf}]},{type:a,value:" has made some effort to standardize how "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002Frendering.html",rel:[o,n,m],target:p},children:[{type:a,value:"rendering"}]}]},{type:a,value:" should work in theory but how browsers adhere to this standard is totally up to them."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Despite these inconsistencies, there are some common principles that are usually the same among all browsers. Let’s understand the common approach a browser takes to render things on the screen and the lifecycle events of this process. To understand this process, I have prepared a "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fgithub.com\u002Fcourse-one\u002Fbrowser-rendering-test",rel:[o,n,m],target:p},children:[{type:a,value:"small project"}]}]},{type:a,value:" to test different rendering scenarios ("},{type:b,tag:j,props:{},children:[{type:a,value:"link below"}]},{type:a,value:D}]},{type:a,value:d},{type:b,tag:T,props:{id:bo},children:[{type:b,tag:k,props:{href:"#parsing-and-external-resources",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:b,tag:g,props:{},children:[{type:a,value:bq}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:"Parsing"}]},{type:a,value:" is the process of reading HTML content and constructing a DOM tree from it. Hence the process is also called "},{type:b,tag:g,props:{},children:[{type:a,value:"DOM parsing"}]},{type:a,value:" and the program that does that is called the "},{type:b,tag:g,props:{},children:[{type:a,value:"DOM parser"}]},{type:a,value:G}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Most browsers provide the "},{type:b,tag:h,props:{},children:[{type:a,value:"[DOMParser](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FDOMParser)"}]},{type:a,value:" Web API to construct a DOM tree from the HTML code. An instance of "},{type:b,tag:h,props:{},children:[{type:a,value:"DOMParser"}]},{type:a,value:" class represents a DOM parser and using the "},{type:b,tag:h,props:{},children:[{type:a,value:"parseFromString"}]},{type:a,value:" prototype method, we can parse raw HTML text ("},{type:b,tag:j,props:{},children:[{type:a,value:h}]},{type:a,value:") into a DOM tree ("},{type:b,tag:j,props:{},children:[{type:a,value:"as shown below"}]},{type:a,value:D}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:bh,src:bh},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"When the browser request for a webpage and server responds with some HTML text (with Content-Type header set to text\u002Fhtml), a browser may start parsing the HTML as soon as a few characters or lines of the entire document are available. Hence the browser can build the DOM tree incrementally, one node at a time. The browser parses HTML from top to bottom and not anywhere in the middle since the HTML represents a nested tree-like structure."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:bi,src:bi},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"In the above example, we have accessed the incremental.html file from our Node server and set the network speed to only 10kbps (from the Network panel). Since it will take a long time for the browser to load (download) this file (as it contains 1000 h1 elements), the browser constructs a DOM tree from the first few bytes and prints them on the screen (as it downloads the remaining content of the HTML file in the background)."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:bj,src:bj},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"If you have a look at the "},{type:b,tag:g,props:{},children:[{type:a,value:bk}]},{type:a,value:" chart of the above request, you will be able to see some "},{type:b,tag:g,props:{},children:[{type:a,value:"events"}]},{type:a,value:" in the "},{type:b,tag:g,props:{},children:[{type:a,value:"Timing"}]},{type:a,value:" row. These events are commonly known as "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fweb.dev\u002Fuser-centric-performance-metrics\u002F#important-metrics-to-measure",rel:[o,n,m],target:p},children:[{type:a,value:"performance metrics"}]}]},{type:a,value:". When these events are placed "},{type:b,tag:g,props:{},children:[{type:a,value:"as close as possible to each other"}]},{type:a,value:" and happen "},{type:b,tag:g,props:{},children:[{type:a,value:"as early as possible"}]},{type:a,value:", better the "},{type:b,tag:g,props:{},children:[{type:a,value:"user experience"}]},{type:a,value:G}]},{type:a,value:d},{type:b,tag:B,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"💡 Use the ⟳ icon in the Performance tab to capture a performance profile."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:V},{type:b,tag:h,props:{},children:[{type:a,value:au}]},{type:a,value:bn},{type:b,tag:g,props:{},children:[{type:a,value:"First Paint"}]},{type:a,value:", which means the time at which the browser has started printing things on the screen ("},{type:b,tag:j,props:{},children:[{type:a,value:"could be as simple as the first pixel of the background color of the body"}]},{type:a,value:D}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:V},{type:b,tag:h,props:{},children:[{type:a,value:av}]},{type:a,value:bn},{type:b,tag:g,props:{},children:[{type:a,value:"First Contentful Paint"}]},{type:a,value:" which means the time at which the browser has rendered the first pixel of the content such as "},{type:b,tag:g,props:{},children:[{type:a,value:a}]},{type:a,value:ai},{type:b,tag:g,props:{},children:[{type:a,value:bp}]},{type:a,value:". The "},{type:b,tag:h,props:{},children:[{type:a,value:aw}]},{type:a,value:" is an acronym of the "},{type:b,tag:g,props:{},children:[{type:a,value:"Largest Contentful Paint"}]},{type:a,value:" which means the time at which the browser has rendered large pieces of text or image."}]},{type:a,value:d},{type:b,tag:B,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"💡 You might have heard about FMP (first meaningful paint) which is also a metric similar to LCP but it has been dropped from Chrome in favor of LCP."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:V},{type:b,tag:h,props:{},children:[{type:a,value:"L"}]},{type:a,value:br},{type:b,tag:h,props:{},children:[{type:a,value:"[onload](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FWindow\u002Fload_event)"}]},{type:a,value:" event which is emitted by the browser on the "},{type:b,tag:h,props:{},children:[{type:a,value:an}]},{type:a,value:" object. Similarly, the "},{type:b,tag:h,props:{},children:[{type:a,value:y}]},{type:a,value:br},{type:b,tag:h,props:{},children:[{type:a,value:bu}]},{type:a,value:" event which is emitted on the "},{type:b,tag:h,props:{},children:[{type:a,value:"document"}]},{type:a,value:" object but it bubbles up to "},{type:b,tag:h,props:{},children:[{type:a,value:an}]},{type:a,value:", hence you can listen to it on the "},{type:b,tag:h,props:{},children:[{type:a,value:an}]},{type:a,value:" as well. These events are a little complex to understand, so we will discuss them in a bit."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Whenever the browser encounters an "},{type:b,tag:g,props:{},children:[{type:a,value:"external resource"}]},{type:a,value:" such as a "},{type:b,tag:g,props:{},children:[{type:a,value:t}]},{type:a,value:bv},{type:b,tag:j,props:{},children:[{type:a,value:bw}]},{type:a,value:bx},{type:b,tag:h,props:{},children:[{type:a,value:"\u003Cscript src=\"*url*\"\u003E\u003C\u002Fscript\u003E"}]},{type:a,value:" element, a "},{type:b,tag:g,props:{},children:[{type:a,value:az}]},{type:a,value:bv},{type:b,tag:j,props:{},children:[{type:a,value:by}]},{type:a,value:bx},{type:b,tag:h,props:{},children:[{type:a,value:"\u003Clink rel=\"stylesheet\" href=\"*url*\"\u002F\u003E"}]},{type:a,value:" tag, an image file via "},{type:b,tag:h,props:{},children:[{type:a,value:"\u003Cimg src=\"*url*\" \u002F\u003E"}]},{type:a,value:" element or any other external resource, the browser will start the download of that file in the background ("},{type:b,tag:j,props:{},children:[{type:a,value:"away from the "},{type:b,tag:g,props:{},children:[{type:a,value:bz}]},{type:a,value:" of the JavaScript execution"}]},{type:a,value:D}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"The most important thing to remember is the DOM parsing normally happens on the "},{type:b,tag:g,props:{},children:[{type:a,value:bz}]},{type:a,value:". So if the main JavaScript execution thread is busy, DOM parsing will not progress until the thread is free. Why that’s so important you may ask? Because "},{type:b,tag:h,props:{},children:[{type:a,value:t}]},{type:a,value:" elements are "},{type:b,tag:g,props:{},children:[{type:a,value:bA}]},{type:a,value:". Every external file requests such as "},{type:b,tag:g,props:{},children:[{type:a,value:bp}]},{type:a,value:A},{type:b,tag:g,props:{},children:[{type:a,value:az}]},{type:a,value:A},{type:b,tag:g,props:{},children:[{type:a,value:"pdf"}]},{type:a,value:A},{type:b,tag:g,props:{},children:[{type:a,value:"video"}]},{type:a,value:", etc. do not block DOM construction ("},{type:b,tag:j,props:{},children:[{type:a,value:"parsing"}]},{type:a,value:") except script ("},{type:b,tag:j,props:{},children:[{type:b,tag:h,props:{},children:[{type:a,value:".js"}]}]},{type:a,value:") file requests."}]},{type:a,value:d},{type:b,tag:M,props:{id:bs},children:[{type:b,tag:k,props:{href:"#parser-blocking-scripts",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:b,tag:g,props:{},children:[{type:a,value:bt}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"A "},{type:b,tag:g,props:{},children:[{type:a,value:"parser-blocking script"}]},{type:a,value:" is a script ("},{type:b,tag:j,props:{},children:[{type:a,value:bw}]},{type:a,value:") file\u002Fcode that stops the parsing of the HTML. When the browser encounters a "},{type:b,tag:h,props:{},children:[{type:a,value:t}]},{type:a,value:" element, if it an embedded script, then it will "},{type:b,tag:g,props:{},children:[{type:a,value:bB}]},{type:a,value:" that script first and then continue parsing the HTML to construct the DOM tree. So all "},{type:b,tag:g,props:{},children:[{type:a,value:"embedded scripts are parser-blocking"}]},{type:a,value:", end of the discussion."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"If the "},{type:b,tag:h,props:{},children:[{type:a,value:t}]},{type:a,value:" element is an "},{type:b,tag:g,props:{},children:[{type:a,value:"external script file"}]},{type:a,value:", the browser will start the download of the external script file off the main thread but it will "},{type:b,tag:g,props:{},children:[{type:a,value:"halt the execution"}]},{type:a,value:" of the main thread until that file is downloaded. That means no more DOM parsing until the script file is downloaded."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Once the script file is downloaded, the browser will first "},{type:b,tag:g,props:{},children:[{type:a,value:bB}]},{type:a,value:" the downloaded script file on the main thread ("},{type:b,tag:j,props:{},children:[{type:a,value:"obviously"}]},{type:a,value:") and then continue with the DOM parsing. If the browser again finds another "},{type:b,tag:h,props:{},children:[{type:a,value:t}]},{type:a,value:" element in HTML, it will perform the same operation. So why browser has to halt the DOM parsing until JavaScript is downloaded and executed?"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"The browser exposes DOM API to the JavaScript runtime, which means we can access and manipulate DOM elements from the JavaScript. This is how dynamic web frameworks such as "},{type:b,tag:g,props:{},children:[{type:a,value:"React"}]},{type:a,value:Q},{type:b,tag:g,props:{},children:[{type:a,value:"Angular"}]},{type:a,value:" works. But if the browser wishes to run DOM parsing and script execution "},{type:b,tag:g,props:{},children:[{type:a,value:"parallelly"}]},{type:a,value:", then there could be "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F34510\u002Fwhat-is-a-race-condition",rel:[o,n,m],target:p},children:[{type:a,value:"race conditions"}]}]},{type:a,value:" between the DOM parser thread and the main thread which is why DOM parsing must happen on the main thread."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"However, halting DOM parsing while the script file is being downloaded in the background is totally unnecessary in most cases. Hence HTML5 gives us the "},{type:b,tag:h,props:{},children:[{type:a,value:"[async](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FHTML\u002FElement\u002Fscript)"}]},{type:a,value:bC},{type:b,tag:h,props:{},children:[{type:a,value:t}]},{type:a,value:" tag. When DOM parser encounters an external "},{type:b,tag:h,props:{},children:[{type:a,value:t}]},{type:a,value:" element with "},{type:b,tag:h,props:{},children:[{type:a,value:J}]},{type:a,value:" attribute, it will not halt the parsing process while the script file is being downloaded in the background. But once the file is downloaded, the parsing will halt and the script ("},{type:b,tag:j,props:{},children:[{type:a,value:h}]},{type:a,value:") will be executed."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"We also have a magical "},{type:b,tag:h,props:{},children:[{type:a,value:aa}]},{type:a,value:bC},{type:b,tag:h,props:{},children:[{type:a,value:t}]},{type:a,value:" element which works similar to the "},{type:b,tag:h,props:{},children:[{type:a,value:J}]},{type:a,value:" attribute but unlike the "},{type:b,tag:h,props:{},children:[{type:a,value:J}]},{type:a,value:" attribute, the script "},{type:b,tag:g,props:{},children:[{type:a,value:"doesn’t execute"}]},{type:a,value:" even when the file is fully downloaded. All "},{type:b,tag:h,props:{},children:[{type:a,value:aa}]},{type:a,value:" scripts are executed once the parser has parsed all HTML which means the DOM tree is fully constructed. Unlike "},{type:b,tag:h,props:{},children:[{type:a,value:J}]},{type:a,value:" scripts, all "},{type:b,tag:h,props:{},children:[{type:a,value:aa}]},{type:a,value:" scripts are executed in the order they appear in the HTML document ("},{type:b,tag:j,props:{},children:[{type:a,value:"or DOM tree"}]},{type:a,value:D}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"All normal scripts ("},{type:b,tag:j,props:{},children:[{type:a,value:"embedded or external"}]},{type:a,value:bF},{type:b,tag:g,props:{},children:[{type:a,value:bA}]},{type:a,value:" as they halt the construction of DOM. All "},{type:b,tag:h,props:{},children:[{type:a,value:J}]},{type:a,value:bG},{type:b,tag:j,props:{},children:[{type:a,value:"AKA asynchronous scripts"}]},{type:a,value:") do not block parser until they are downloaded. As soon as an "},{type:b,tag:h,props:{},children:[{type:a,value:J}]},{type:a,value:" script is downloaded, it becomes parser-blocking. However, all "},{type:b,tag:h,props:{},children:[{type:a,value:aa}]},{type:a,value:bG},{type:b,tag:j,props:{},children:[{type:a,value:"AKA deferred scripts"}]},{type:a,value:bF},{type:b,tag:g,props:{},children:[{type:a,value:"non-parser-blocking"}]},{type:a,value:" script as they do not block the parser and execute after the DOM tree is fully constructed."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:bH,src:bH},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"In the above example, the parser-blocking.html file contains a parser-blocking script after 30 elements which is why the browser displays 30 elements at first, stops the DOM parsing, and starts loading the script file. The second script file doesn't block the parsing as it has the defer attribute, so it will execute once the DOM tree is fully constructed."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:bI,src:bI},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"If we take a look at the "},{type:b,tag:g,props:{},children:[{type:a,value:bk}]},{type:a,value:" panel, the "},{type:b,tag:h,props:{},children:[{type:a,value:au}]},{type:a,value:Q},{type:b,tag:h,props:{},children:[{type:a,value:av}]},{type:a,value:" happens as soon as possible ("},{type:b,tag:j,props:{},children:[{type:a,value:"hidden behind the "},{type:b,tag:g,props:{},children:[{type:a,value:"Timings"}]},{type:a,value:" label"}]},{type:a,value:") since the browser starts to build a DOM tree as soon as some HTML content is available, hence it can render some pixels on the screen."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:V},{type:b,tag:h,props:{},children:[{type:a,value:aw}]},{type:a,value:" happens after 5 seconds because the parser-blocking script has blocked the DOM parsing for 5 seconds ("},{type:b,tag:j,props:{},children:[{type:a,value:"its download time"}]},{type:a,value:") and only 30 text elements were rendered on the screen when the DOM parser was blocked which is not sufficient to be called as the largest contentful paint ("},{type:b,tag:j,props:{},children:[{type:a,value:"according to Google Chrome standards"}]},{type:a,value:"). But once the script was downloaded and executed, DOM parsing resumed and large content was rendered on the screen which led to the firing of "},{type:b,tag:h,props:{},children:[{type:a,value:aw}]},{type:a,value:" event."}]},{type:a,value:d},{type:b,tag:B,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"💡 Parser-blocking is also referred to as render-blocking as rendering won’t happen unless the DOM tree is constructed, but these two are quite different things as we will see in a bit."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Some browsers may incorporate a "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FGlossary\u002Fspeculative_parsing",rel:[o,n,m],target:p},children:[{type:a,value:"speculative parsing"}]}]},{type:a,value:" strategy where the HTML parsing ("},{type:b,tag:j,props:{},children:[{type:a,value:"but not the DOM tree construction"}]},{type:a,value:") is offloaded to a separate thread so that browser can read elements such as "},{type:b,tag:h,props:{},children:[{type:a,value:_}]},{type:a,value:ar},{type:b,tag:j,props:{},children:[{type:a,value:by}]},{type:a,value:"), "},{type:b,tag:h,props:{},children:[{type:a,value:t}]},{type:a,value:A},{type:b,tag:h,props:{},children:[{type:a,value:s}]},{type:a,value:", etc. and download these resources "},{type:b,tag:g,props:{},children:[{type:a,value:"eagerly"}]},{type:a,value:G}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"This is quite helpful if you have three "},{type:b,tag:h,props:{},children:[{type:a,value:t}]},{type:a,value:" elements one after the other, but the browser won’t be able to start the download of the second script until the first script is downloaded as the DOM parser couldn’t read the second "},{type:b,tag:h,props:{},children:[{type:a,value:t}]},{type:a,value:" element. We can fix this easily by using "},{type:b,tag:h,props:{},children:[{type:a,value:J}]},{type:a,value:" tag but asynchronous scripts are not guaranteed to execute in order."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"The reason it is called speculative parsing because the browser is making a "},{type:b,tag:g,props:{},children:[{type:a,value:"speculation"}]},{type:a,value:" that a particular resource is expected to load in the future, so better load it now in the background. However, if some JavaScript manipulates DOM and removes\u002Fhides the element with an external resource, then speculation fails and these files were loaded for nothing. Tough."}]},{type:a,value:d},{type:b,tag:B,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"💡 Every browser has a mind of its own, so when or if speculative parsing will happen is not guaranteed. However, you can ask the browser to load some resources ahead of time using the "},{type:b,tag:_,props:{rel:["preload"]},children:[]},{type:a,value:" element."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:M,props:{id:bD},children:[{type:b,tag:k,props:{href:"#render-blocking-css",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:b,tag:g,props:{},children:[{type:a,value:bT}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"As we learned, any external resource request except a parser-blocking script file doesn’t block the DOM parsing process. Hence CSS ("},{type:b,tag:j,props:{},children:[{type:a,value:"including embedded"}]},{type:a,value:") doesn’t block the DOM parser…("},{type:b,tag:j,props:{},children:[{type:a,value:"wait for it"}]},{type:a,value:")…"},{type:b,tag:g,props:{},children:[{type:a,value:"directly"}]},{type:a,value:". Yes, "},{type:b,tag:g,props:{},children:[{type:a,value:"CSS can block DOM parsing"}]},{type:a,value:" but for that, we need to understand the rendering processes."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"The browser engines inside your browser construct the DOM tree from HTML content received as a text document from the server. Similarly, it constructs the "},{type:b,tag:g,props:{},children:[{type:a,value:aU}]},{type:a,value:" tree from the stylesheet content such as from an external CSS file or embedded ("},{type:b,tag:j,props:{},children:[{type:a,value:"as well as inline"}]},{type:a,value:") CSS in the HTML."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Both DOM and CSSOM tree constructions happen on the main thread and these trees are getting constructed "},{type:b,tag:g,props:{},children:[{type:a,value:"concurrently"}]},{type:a,value:". Together they form the "},{type:b,tag:g,props:{},children:[{type:a,value:S}]},{type:a,value:" that is used to print things on the screen which is also getting built incrementally as the DOM tree is getting constructed."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"As we have learned that DOM tree generation is "},{type:b,tag:g,props:{},children:[{type:a,value:"incremental"}]},{type:a,value:" which means as the browser reads HTML, it will add DOM elements to the DOM tree. But that’s not the case with the CSSOM tree. Unlike the DOM tree, CSSOM tree construction is "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FPerformance\u002FCritical_rendering_path#CSS_Object_Model",rel:[o,n,m],target:p},children:[{type:a,value:"not incremental"}]}]},{type:a,value:" and must happen in a specific manner."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"When browser find "},{type:b,tag:h,props:{},children:[{type:a,value:"\u003Cstyle\u003E"}]},{type:a,value:" block, it will parse all the embedded CSS and update the CSSOM tree with new CSS ("},{type:b,tag:j,props:{},children:[{type:a,value:at}]},{type:a,value:") rules. After that, it will continue parsing the HTML in the normal manner. The same goes for inline styling."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"However, things change drastically when the browser encounters an external stylesheet file. Unlike an external script file, an external stylesheet file is not parser-blocking resources, hence the browser can download it in the background silently and the DOM parsing will continue."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"But unlike the HTML file ("},{type:b,tag:j,props:{},children:[{type:a,value:"for the DOM construction"}]},{type:a,value:"), the browser won’t process the stylesheet file content one byte at a time. This is because browsers can’t build the CSSOM tree incrementally as it reads the CSS content. The reason for that is, a CSS rule at the end of the file might override a CSS rule written at the top of the file."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Hence if the browser starts constructing CSSOM incrementally as it parses the stylesheet content, it will lead to multiple renders of the "},{type:b,tag:g,props:{},children:[{type:a,value:S}]},{type:a,value:" as the same CSSOM nodes are getting updated because of the "},{type:b,tag:g,props:{},children:[{type:a,value:"style overrides rules"}]},{type:a,value:" that appear later in the stylesheet file. It would be an unpleasant user experience to see elements changing styles on the screen as CSS is getting parsed. Since CSS styles are "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fstackoverflow.com\u002Fa\u002F1043046\u002F2790983",rel:[o,n,m],target:p},children:[{type:a,value:"cascading"}]}]},{type:a,value:", one rule change can affect many elements."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Hence browsers do not process external CSS files incrementally and the CSSOM tree update happens at once after all the CSS rules in the stylesheet are processed. Once the CSSOM tree update is completed, then the "},{type:b,tag:g,props:{},children:[{type:a,value:S}]},{type:a,value:" is updated which then is rendered on the screen."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"CSS is a "},{type:b,tag:g,props:{},children:[{type:a,value:bK}]},{type:a,value:" resource. Once the browser makes a request to fetch an external stylesheet, the "},{type:b,tag:g,props:{},children:[{type:a,value:"Render Tree construction is halted"}]},{type:a,value:". Therefore the "},{type:b,tag:g,props:{},children:[{type:a,value:"Critical Rendering Path"}]},{type:a,value:O},{type:b,tag:j,props:{},children:[{type:a,value:"CRP"}]},{type:a,value:") is also stuck and nothing is getting rendered on the screen as demonstrated below. However, the DOM tree construction is still undergoing while the stylesheet is being downloaded in the background."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:bL,src:bL},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"A browser "},{type:b,tag:g,props:{},children:[{type:a,value:"could have"}]},{type:a,value:" used an older state of the CSSOM tree to generate "},{type:b,tag:g,props:{},children:[{type:a,value:S}]},{type:a,value:" as HTML is getting parsed to render things on the screen incrementally. But this has a huge downside. In this case, once the stylesheet is downloaded and parsed, and CSSOM is updated, Render Tree will be updated and rendered on the screen. Now the Render Tree nodes generated with older CSSOM will be "},{type:b,tag:g,props:{},children:[{type:a,value:"repainted with new styles"}]},{type:a,value:" and it could also lead to "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fwebkit.org\u002Fblog\u002F66\u002Fthe-fouc-problem\u002F",rel:[o,n,m],target:p},children:[{type:a,value:"Flash of Unstyled Content"}]}]},{type:a,value:O},{type:b,tag:j,props:{},children:[{type:a,value:"FOUC"}]},{type:a,value:") which is is very bad for UX."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Hence browsers will wait until the stylesheet is loaded and parsed. Once the stylesheet is parsed and CSSOM is updated, the Render Tree is updated, and "},{type:b,tag:g,props:{},children:[{type:a,value:"CRP is unblocked"}]},{type:a,value:" which leads to the paint of Render Tree on the screen. Due to this reason, it is recommended to load all external stylesheets as early as possible, possibly in the "},{type:b,tag:h,props:{},children:[{type:a,value:ab}]},{type:a,value:" section."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Let’s imagine a scenario where the browser has started parsing HTML and it encounters an external stylesheet file. It will start the download of the file in the background, block the CRP, and continue with the DOM parsing. But then it encounters a "},{type:b,tag:h,props:{},children:[{type:a,value:t}]},{type:a,value:" tag. So it will start the download of the external script file and block the DOM parsing. Now the browser is sitting idle waiting for the stylesheet and script file to download completely."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"But this time, the external script file has been "},{type:b,tag:g,props:{},children:[{type:a,value:"downloaded completely"}]},{type:a,value:" while the stylesheet is still being downloaded in the background. Should the browser execute the script file? Is there any harm doing that?"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"As we know, CSSOM provides a high-level JavaScript API to interact with the "},{type:b,tag:g,props:{},children:[{type:a,value:"styles"}]},{type:a,value:" of the DOM elements. For example, you can read or update the background color of a DOM element using "},{type:b,tag:h,props:{},children:[{type:a,value:"elem.style.backgroundColor"}]},{type:a,value:" property. The "},{type:b,tag:h,props:{},children:[{type:a,value:at}]},{type:a,value:" object associated the "},{type:b,tag:h,props:{},children:[{type:a,value:"elem"}]},{type:a,value:" element exposes the CSSOM API and there are many other APIs to do the same ("},{type:b,tag:j,props:{},children:[{type:a,value:"read this "},{type:b,tag:k,props:{href:"https:\u002F\u002Fcss-tricks.com\u002Fan-introduction-and-guide-to-the-css-object-model-cssom\u002F",rel:[o,n,m],target:p},children:[{type:a,value:"css-tricks article"}]}]},{type:a,value:D}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"As a stylesheet is being downloaded background, JavaScript can still execute as the main thread is not being blocked by the loading stylesheet. If our JavaScript program accesses CSS properties of a DOM element ("},{type:b,tag:j,props:{},children:[{type:a,value:"through CSSOM API"}]},{type:a,value:"), we will get a proper value ("},{type:b,tag:j,props:{},children:[{type:a,value:"as per the current state of CSSOM"}]},{type:a,value:D}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"But once the stylesheet is downloaded and parsed, which leads to CSSOM update, our JavaScript now has a bad CSS value of the element since the new CSSOM update could have changed the CSS properties of that DOM element. Due to this reason, it’s not safe to execute JavaScript while the stylesheet is being downloaded."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"As per the "},{type:b,tag:g,props:{},children:[{type:b,tag:k,props:{href:"https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002Fsemantics.html#interactions-of-styling-and-scripting",rel:[o,n,m],target:p},children:[{type:a,value:bf}]}]},{type:a,value:", the browser may download a script file but it will not execute it unless all previous stylesheets are parsed. When a stylesheet blocks the execution of a script, it is called a "},{type:b,tag:g,props:{},children:[{type:a,value:aC}]},{type:a,value:" stylesheet or a "},{type:b,tag:g,props:{},children:[{type:a,value:aC}]},{type:a,value:" CSS."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:bN,src:bN},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:bO},{type:b,tag:h,props:{},children:[{type:a,value:"[script-blocking.html](https:\u002F\u002Fgithub.com\u002Fcourse-one\u002Fbrowser-rendering-test\u002Fblob\u002Fmaster\u002Fhtml\u002Fscript-blocking.html)"}]},{type:a,value:" contains a "},{type:b,tag:h,props:{},children:[{type:a,value:_}]},{type:a,value:bP},{type:b,tag:j,props:{},children:[{type:a,value:"for an external stylesheet"}]},{type:a,value:") followed by a "},{type:b,tag:h,props:{},children:[{type:a,value:t}]},{type:a,value:bP},{type:b,tag:j,props:{},children:[{type:a,value:"for an external JavaScript"}]},{type:a,value:"). Here the script gets downloaded really fast without any delay but the stylesheet takes 6 seconds to download. Hence, even though the script is downloaded completely as we can see from the "},{type:b,tag:g,props:{},children:[{type:a,value:"Network"}]},{type:a,value:" panel, it wasn’t executed by the browser immediately. Only after the stylesheet is loaded, we see the "},{type:b,tag:h,props:{},children:[{type:a,value:"Hello World"}]},{type:a,value:" messaged logged by the script."}]},{type:a,value:d},{type:b,tag:B,props:{},children:[{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"💡 Like async or defer attribute makes script element non-parser-blocking, an external stylesheet can also be marked as non-render-blocking using the media attribute. Using the media attribute value, the browser can make a smart decision when to load the stylesheet."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:M,props:{id:bW},children:[{type:b,tag:k,props:{href:"#documents-domcontentloaded-event",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:b,tag:g,props:{},children:[{type:a,value:"Document’s "},{type:b,tag:h,props:{},children:[{type:a,value:bQ}]},{type:a,value:" Event"}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:V},{type:b,tag:h,props:{},children:[{type:a,value:bu}]},{type:a,value:O},{type:b,tag:j,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:y}]}]},{type:a,value:") event marks a point in time when the browser has constructed a complete DOM tree from all the available HTML. But there are a lot of factors involved that can change when the "},{type:b,tag:h,props:{},children:[{type:a,value:y}]},{type:a,value:" event is fired."}]},{type:a,value:d},{type:b,tag:F,props:{className:[af]},children:[{type:b,tag:ag,props:{className:[ah,"language-text"]},children:[{type:b,tag:h,props:{},children:[{type:a,value:"document.addEventListener( 'DOMContentLoaded', function(e) {\n    console.log( 'DOM is fully parsed!' );\n} );\n"}]}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"If our HTML doesn’t contain any scripts, DOM parsing won’t get blocked and "},{type:b,tag:h,props:{},children:[{type:a,value:y}]},{type:a,value:" will fire as quickly as the browser can parse the entire HTML. If we have parser-blocking scripts, then "},{type:b,tag:h,props:{},children:[{type:a,value:y}]},{type:a,value:" has to wait until all parser-blocking scripts are downloaded and executed."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Things get a little complicated when stylesheets are thrown into the picture. Even though you have no external scripts, "},{type:b,tag:h,props:{},children:[{type:a,value:y}]},{type:a,value:" will wait until all stylesheets are loaded. Since "},{type:b,tag:h,props:{},children:[{type:a,value:y}]},{type:a,value:" marks a point in time when the entire DOM tree is ready, but DOM won’t be safe to access ("},{type:b,tag:j,props:{},children:[{type:a,value:"for the style information"}]},{type:a,value:") unless CSSOM is also fully constructed. Hence most browsers wait until all external stylesheets are loaded and parsed."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Script-blocking stylesheet will obviously delay the "},{type:b,tag:h,props:{},children:[{type:a,value:y}]},{type:a,value:". In this case, since the script is waiting for the stylesheet to load, the DOM tree is not getting constructed."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:h,props:{},children:[{type:a,value:y}]},{type:a,value:" is one of the website performance metrics. We should optimize the "},{type:b,tag:h,props:{},children:[{type:a,value:y}]},{type:a,value:" to be as small as possible ("},{type:b,tag:j,props:{},children:[{type:a,value:"the time at which it occurs"}]},{type:a,value:"). One of the best practices is to use "},{type:b,tag:h,props:{},children:[{type:a,value:aa}]},{type:a,value:Q},{type:b,tag:h,props:{},children:[{type:a,value:J}]},{type:a,value:" tag for "},{type:b,tag:h,props:{},children:[{type:a,value:t}]},{type:a,value:" element whenever possible so that browser can perform other things while scripts are being downloaded in the background. Second, we should optimize the "},{type:b,tag:g,props:{},children:[{type:a,value:aC}]},{type:a,value:Q},{type:b,tag:g,props:{},children:[{type:a,value:bK}]},{type:a,value:" stylesheets."}]},{type:a,value:d},{type:b,tag:M,props:{id:aH},children:[{type:b,tag:k,props:{href:"#windows-load-event",ariaHidden:w,tabIndex:v},children:[{type:b,tag:c,props:{className:[x,u]},children:[]}]},{type:b,tag:g,props:{},children:[{type:a,value:"Window’s "},{type:b,tag:h,props:{},children:[{type:a,value:bR}]},{type:a,value:" event"}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"As we know JavaScript can block DOM tree generation but that’s not the case with external stylesheets and files such as images, videos, etc."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:V},{type:b,tag:h,props:{},children:[{type:a,value:bQ}]},{type:a,value:" event marks a point in time when the DOM tree is fully constructed and it is safe to access, the "},{type:b,tag:h,props:{},children:[{type:a,value:"window.onload"}]},{type:a,value:" event marks a point in time when external stylesheets and files are downloaded and our web application ("},{type:b,tag:j,props:{},children:[{type:a,value:"complete"}]},{type:a,value:") has finished downloading."}]},{type:a,value:d},{type:b,tag:F,props:{className:[af]},children:[{type:b,tag:ag,props:{className:[ah,"language-jsx"]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[e,"dom","variable"]},children:[{type:a,value:an}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:G}]},{type:b,tag:c,props:{className:[e,bS,aD,bU]},children:[{type:a,value:"addEventListener"}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:ar}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,bV]},children:[{type:a,value:"'load'"}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:","}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,"keyword"]},children:[{type:a,value:aD}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:ar}]},{type:b,tag:c,props:{className:[e,"parameter"]},children:[{type:a,value:"e"}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:aE}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:R}]},{type:a,value:"\n  "},{type:b,tag:c,props:{className:[e,bX,"class-name"]},children:[{type:a,value:bX}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:G}]},{type:b,tag:c,props:{className:[e,bS,aD,bU]},children:[{type:a,value:"log"}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:ar}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,bV]},children:[{type:a,value:"'Page is fully loaded!'"}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:aE}]},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:C}]},{type:a,value:d},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:W}]},{type:a,value:q},{type:b,tag:c,props:{className:[e,i]},children:[{type:a,value:aE}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:s,props:{alt:bY,src:bY},children:[]}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:bO},{type:b,tag:h,props:{},children:[{type:a,value:"[rendering.html](https:\u002F\u002Fgithub.com\u002Fcourse-one\u002Fbrowser-rendering-test\u002Fblob\u002Fmaster\u002Fhtml\u002Frendering.html)"}]},{type:a,value:" file has an external stylesheet in the "},{type:b,tag:h,props:{},children:[{type:a,value:ab}]},{type:a,value:" that takes around 5 seconds to download. Since it’s in the "},{type:b,tag:h,props:{},children:[{type:a,value:ab}]},{type:a,value:" section, the "},{type:b,tag:h,props:{},children:[{type:a,value:au}]},{type:a,value:Q},{type:b,tag:h,props:{},children:[{type:a,value:av}]},{type:a,value:" occurs after 5 seconds since the stylesheet will block the rendering of any content below it ("},{type:b,tag:j,props:{},children:[{type:a,value:"as it blocks CRP"}]},{type:a,value:D}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"After that, we have an "},{type:b,tag:h,props:{},children:[{type:a,value:s}]},{type:a,value:" element that loads an image that takes around 10 seconds to download. So the browser will keep downloading this file in the background and move on with the DOM parsing and rendering ("},{type:b,tag:j,props:{},children:[{type:a,value:"as an external image resource is neither parser-blocking nor render-blocking"}]},{type:a,value:D}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Next, we have three external JavaScript files and they take 3s, 6s, and 9s to download respectively and most importantly, they are not "},{type:b,tag:h,props:{},children:[{type:a,value:J}]},{type:a,value:". This means the total load time should be close to "},{type:b,tag:g,props:{},children:[{type:a,value:"18 seconds"}]},{type:a,value:" as the subsequent script won’t start downloading before the previous one is executed. However, looking at the "},{type:b,tag:h,props:{},children:[{type:a,value:y}]},{type:a,value:" event, our browser seemed to have used the "},{type:b,tag:g,props:{},children:[{type:a,value:"speculative strategy"}]},{type:a,value:" to eagerly download the script files so the total time to load is close to "},{type:b,tag:g,props:{},children:[{type:a,value:bZ}]},{type:a,value:G}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Since the last file to download that can affect the "},{type:b,tag:h,props:{},children:[{type:a,value:y}]},{type:a,value:" is the last script file with the load time of "},{type:b,tag:g,props:{},children:[{type:a,value:bZ}]},{type:a,value:O},{type:b,tag:j,props:{},children:[{type:a,value:"since stylesheet has already been downloaded in 5 seconds"}]},{type:a,value:"), the "},{type:b,tag:h,props:{},children:[{type:a,value:y}]},{type:a,value:" event occurs around "},{type:b,tag:g,props:{},children:[{type:a,value:"9.1 seconds"}]},{type:a,value:G}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"We also had another external resource which was the image file and it kept loading in the background. Once it was fully downloaded ("},{type:b,tag:j,props:{},children:[{type:a,value:"which takes 10 seconds"}]},{type:a,value:"), the window’s "},{type:b,tag:h,props:{},children:[{type:a,value:bR}]},{type:a,value:" event was fired after "},{type:b,tag:g,props:{},children:[{type:a,value:"10.2 seconds"}]},{type:a,value:" which marks that the webpage ("},{type:b,tag:j,props:{},children:[{type:a,value:"application"}]},{type:a,value:") is fully loaded."}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:a,value:"Github repo:"}]},{type:a,value:d},{type:b,tag:f,props:{},children:[{type:b,tag:k,props:{href:b_,rel:[o,n,m],target:p},children:[{type:a,value:b_}]}]}]},dir:"\u002Fcollection",path:"\u002Fcollection\u002Fhow-the-browser-renders-a-web-page-dom-cssom-and-rendering",extension:".md",createdAt:aM,updatedAt:aM}}],fetch:[],mutations:void 0}}("text","element","span","\n","token","p","strong","code","punctuation","em","a","tag","noreferrer","noopener","nofollow","_blank"," ","\u003E","img","script","icon-link",-1,"true","icon","DCL","\n    ",", ","blockquote",";",").","property","div",".","\u003C",":","async","\u003C\u002F",2,"h2","\""," (",3," and ","{","Render Tree","h3","number","The ","}","selector","\n        ","color","link","","defer","head","class","\n\n","px","nuxt-content-highlight","pre","line-numbers"," or ","html","unit","body","=","window","attr-equals","attr-value","attr-name","(",null,"style","FP","FCP","LCP","font-size","layout","stylesheet","title",".container","script-blocking","function",")","\n      \n        ","comment","windows-load-event","css-object-model-cssom","CSS Object Model (CSSOM)","0","render-tree","2021-07-25T08:32:20.891Z","rendering-sequence","Document Object Model (DOM)","Rendering Sequence","layout-operation","\n          ","h1","combinator","CSSOM","Layout operation","paint-operation","https:\u002F\u002Fs3-us-west-2.amazonaws.com\u002Fsecure.notion-static.com\u002Fb808a782-7bec-4f87-a5e7-1b2007061a03\u002F1_DJg1yRx-AzkZposWbJKcaA.png","Paint operation","display:none;","https:\u002F\u002Fs3-us-west-2.amazonaws.com\u002Fsecure.notion-static.com\u002Ff4e7b5a2-aba0-4267-b779-058b98328fc8\u002F1_8HnhiojSoPaJAWkruPhDwA.png","compositing-operation","Compositing operation","reflow","browser-engines","https:\u002F\u002Fs3-us-west-2.amazonaws.com\u002Fsecure.notion-static.com\u002Fa1293706-01c0-4984-8240-130b65c746fd\u002F1_yQJkz12sPxS-kJoMDqzbEQ.png","WebKit","HTML5 specification","Browser engines","https:\u002F\u002Fs3-us-west-2.amazonaws.com\u002Fsecure.notion-static.com\u002F8632d843-373f-470a-8d8a-461e7a2efadb\u002F1_DTO0PBRawrEdZakWloQVjg.png","https:\u002F\u002Fmiro.medium.com\u002Fmax\u002F2000\u002F1*1bcaVVjG_077zHVzGfHUyw.gif","https:\u002F\u002Fs3-us-west-2.amazonaws.com\u002Fsecure.notion-static.com\u002F6e8ceed9-9af7-41a1-be77-3deb75b2b693\u002F1_iFkRxUmwMKObC9hEqRiywQ.png","Performance","rendering-process-in-browsers","Rendering Process in browsers"," is an acronym of ","parsing-and-external-resources","image","Parsing and External Resources"," stands for the ","parser-blocking-scripts","Parser-Blocking Scripts","[DOMContentLoaded](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FDocument\u002FDOMContentLoaded_event)"," file (","JavaScript",") via ","CSS","main thread","parser-blocking","execute"," attribute for the ","render-blocking-css","[HTMLDivElement](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FHTMLDivElement)",") are "," scripts (","https:\u002F\u002Fmiro.medium.com\u002Fmax\u002F2000\u002F1*5xdQ1j6Ai2PZYCRQuXM5wg.gif","https:\u002F\u002Fs3-us-west-2.amazonaws.com\u002Fsecure.notion-static.com\u002F89284082-b80c-4067-8cfb-18cf173b964c\u002F1_pxkIXo-LvXEkGaJJeR9cyA.png","document-object-model-dom","render-blocking","https:\u002F\u002Fmiro.medium.com\u002Fmax\u002F2000\u002F1*y3QmSfyergjmVV32nH7tPA.gif"," etc.","https:\u002F\u002Fmiro.medium.com\u002Fmax\u002F2000\u002F1*atsh0R6Do25SriYvvskkgA.gif","In the above example, the "," tag (","DOMContentLoaded","load","method","Render-Blocking CSS","property-access","string","documents-domcontentloaded-event","console","https:\u002F\u002Fs3-us-west-2.amazonaws.com\u002Fsecure.notion-static.com\u002F9d1df2a7-3095-4009-a986-52f01515e6fe\u002F1_DuLBecXpJjFh1qnakXjWWg.png","9 seconds","https:\u002F\u002Fgithub.com\u002Fcourse-one\u002Fbrowser-rendering-test\u002Ftree\u002Fmaster","[Node](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FNode)")));